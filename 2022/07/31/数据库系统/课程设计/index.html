<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>数据库-课程设计</title><meta name="author" content="HogarHuang"><meta name="copyright" content="HogarHuang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据库系统课程设计报告  B+树 BulkLoading 多核并行设计（小组作业）   Ⅰ. B+树 BulkLoading 过程理解1.1 BulkLoading 的基本思想​        在理解 BulkLoading 过程之前，要先理解 B+ 树的结构特性：首先，B+ 树只在叶子节点中保存数据，非叶子节点只保存索引，叶子结点的数据又根据关键字从小到大顺序排序。 ​        我们单看叶">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库-课程设计">
<meta property="og:url" content="https://huanghj78.github.io/2022/07/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/index.html">
<meta property="og:site_name" content="Hogar&#39;s Blog">
<meta property="og:description" content="数据库系统课程设计报告  B+树 BulkLoading 多核并行设计（小组作业）   Ⅰ. B+树 BulkLoading 过程理解1.1 BulkLoading 的基本思想​        在理解 BulkLoading 过程之前，要先理解 B+ 树的结构特性：首先，B+ 树只在叶子节点中保存数据，非叶子节点只保存索引，叶子结点的数据又根据关键字从小到大顺序排序。 ​        我们单看叶">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://huanghj78.github.io/images/background.jpg">
<meta property="article:published_time" content="2022-07-30T16:22:52.380Z">
<meta property="article:modified_time" content="2022-07-30T16:31:46.010Z">
<meta property="article:author" content="HogarHuang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huanghj78.github.io/images/background.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huanghj78.github.io/2022/07/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: HogarHuang","link":"Link: ","source":"Source: Hogar's Blog","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据库-课程设计',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-31 00:31:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="is-center"><div class="avatar-img"><img src="/img/luka.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">HogarHuang</div><div class="author-info__description">1353188493@qq.com</div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-clock"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/records"><i class="fa-fw fas fa-comment-dots"></i><span> 随记</span></a></div><div class="menus_item"><a class="site-page" href="/gedan"><i class="fa-fw fas fa-music"></i><span> 歌单</span></a></div><div class="menus_item"><a class="site-page" href="/game"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk"><i class="fa-fw fa fa-heartbeat"></i><span> 时光</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-tools"></i><span> 工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/google"><span> 镜像</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://json.xbyzs.cf"><span> Json格式化</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://draw.xbyzs.cf"><span> Draw画布</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://enkey.xbyzs.cf"><span> EnKey</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hogar's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-clock"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/records"><i class="fa-fw fas fa-comment-dots"></i><span> 随记</span></a></div><div class="menus_item"><a class="site-page" href="/gedan"><i class="fa-fw fas fa-music"></i><span> 歌单</span></a></div><div class="menus_item"><a class="site-page" href="/game"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk"><i class="fa-fw fa fa-heartbeat"></i><span> 时光</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-tools"></i><span> 工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/google"><span> 镜像</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://json.xbyzs.cf"><span> Json格式化</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://draw.xbyzs.cf"><span> Draw画布</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://enkey.xbyzs.cf"><span> EnKey</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">数据库-课程设计</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">Created</span><time datetime="2022-07-30T16:22:52.380Z" title="Created 2022-07-31 00:22:52">2022-07-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/">数据库系统</a></span></div><div class="meta-secondline"></div></div></div><article class="post-content" id="article-container"><center><h1>数据库系统课程设计报告</h1></center>

<center><h2>B+树 BulkLoading 多核并行设计（小组作业）</h2></center>


<h2 id="Ⅰ-B-树-BulkLoading-过程理解"><a href="#Ⅰ-B-树-BulkLoading-过程理解" class="headerlink" title="Ⅰ. B+树 BulkLoading 过程理解"></a>Ⅰ. B+树 BulkLoading 过程理解</h2><h3 id="1-1-BulkLoading-的基本思想"><a href="#1-1-BulkLoading-的基本思想" class="headerlink" title="1.1 BulkLoading 的基本思想"></a>1.1 BulkLoading 的基本思想</h3><p>​        在理解 BulkLoading 过程之前，要先理解 B+ 树的结构特性：首先，B+ 树只在叶子节点中保存数据，非叶子节点只保存索引，叶子结点的数据又根据关键字从小到大顺序排序。</p>
<p>​        我们单看叶子节点一层，就可以发现起始它和一个有序的数据数组在形状上是一致的。这意味着如果我们的现有数据是有序排列的，我们就可以直接从小到大“铺”到叶子节点上。再加上B+树的子节点的个数有限制，故我们可以直接估算出要多少个叶子节点，多少个相邻的叶子节点有一个共同的父索引节点，把上述过程同样运用到索引节点上，我们就可以自底向上地构建出一棵完整的B+树。</p>
<p>​        得到一个BulkLoading过程的一个完整描述：<strong>先从底层叶子节点构建，从左往右按顺序构建一个双向链表；从下往上，一层层构建索引节点，每一层也是从左往右构建索引节点。</strong></p>
<h3 id="1-2-结合实现理解-BulkLoading"><a href="#1-2-结合实现理解-BulkLoading" class="headerlink" title="1.2 结合实现理解 BulkLoading"></a>1.2 结合实现理解 BulkLoading</h3><p>讨论 BulkLoading 的实现细节：节点的结构、磁盘文件的数据对应 。</p>
<ul>
<li><p>叶子节点：相邻节点之间有互相指向的指针，叶子层构成了一个双向链表。每个节点有两个数组，一个储存Key，一个储存Value，一个Key对应有16个Value，这里的 Value 就是实际的数据，也就是数据项（Data Entry）。</p>
</li>
<li><p>索引节点：每一层的相邻的索引节点也存在双向指针，索引节点都是根据下一层的子节点生成的，每个索引节点有两个数组，一个存储Key，一个存储指向子节点的指针，二者数量相等。一个键值Key和一个指针就构成了一个索引项（Index Entry）。</p>
</li>
<li><p>与磁盘文件的关系：磁盘文件被划分为一个个块（Block），每一个节点就对应一个块，块通过块号区分，表示节点存储到文件的区域编号。这样，索引项中所谓的指针，就可以用块号来表示。</p>
</li>
</ul>
<p>​        这样，BulkLoading 的过程就包含：在内存中组织叶子节点和索引节点，组织的方式就是创建与块一样大的缓冲区，将数据项、索引项拷贝进去，然后再写入到磁盘块里。（区分这些过程有利于并行实现）</p>
<p>​        因为块号的分配是连续的，块的大小是固定的。在 BulkLoading 过程中，我们只需要记录下一层中第一个块号和最后一个块号，就可以直接算出上一层节点的所有子节点的块号，无需访问子节点。</p>
<p>​        在B+树中一个节点的索引值可以设置为第一个项的键值，因为 BulkLoading 是自底向上的构造过程，节点的索引值可以直接给出，且过程中不会改变，不需要B+树插入删除节点时的那样进行动态调整。在设计上采用 On-the-fly 的策略，在一层一层循环构建的过程中，线程函数每次都保存一层的键值并返回，键值数组再用于构建上一层节点，无需进行IO访问。</p>
<h3 id="1-3-BulkLoading-的利弊"><a href="#1-3-BulkLoading-的利弊" class="headerlink" title="1.3 BulkLoading 的利弊"></a>1.3 BulkLoading 的利弊</h3><p>​        相比于通过插入节点构造B+树，BulkLoding充分利用了数据有序的特性，让每一个节点构造过程的复杂度都为O(1)，构造过程中不存在节点的分叉、合并等调整，生成B+树的过程非常快。</p>
<p>​        通过BulkLoading构造B+树也可能存在潜在的问题：因为每一个节点从左到右都是尽可能填满的，当需要插入新节点时，B+树结构的变动可能会非常大，会产生较大的时间开销。</p>
<p>​        或许我们可以加入一个填充因子来控制BulkLoading每次为一个叶子节点填出的数据项的个数，让叶子节点的数据项不是满的，这样可以减弱插入节点对B+树结构造成的影响。</p>
<h2 id="Ⅱ-并行设计思路"><a href="#Ⅱ-并行设计思路" class="headerlink" title="Ⅱ. 并行设计思路"></a>Ⅱ. 并行设计思路</h2><h3 id="2-1-基本想法"><a href="#2-1-基本想法" class="headerlink" title="2.1 基本想法"></a>2.1 基本想法</h3><p>​        首先，需要思考的问题是在批量加载的哪些步骤可以并行，通过阅读串行代码我们可知，构建B+树的串行过程大致为：读取数据并在内存中创建一个节点对象存放数据，然后再通过系统函数 <code>fwrite()</code> 将该节点中的数据写入到磁盘中。</p>
<p>​        我们考虑到，节点数据写到文件的过程由于文件指针的限制无法并行，同一时刻只能有一个线程写磁盘，因此可以创建内存缓冲区缓冲节点数据，在获取写文件权限后将内存中节点写出。</p>
<p>​        由于写磁盘的速度低于写内存，BulkLoading 运行速度的瓶颈可能在于写硬盘，因此要充分提高CPU和磁盘IO的并行度，来减少IO造成的护航效应。</p>
<p>​        引入互斥锁：由于写硬盘不能并行，因此需要一个互斥锁保证同一时刻只有一个线程能够将已经加载到内存的节点数据写入硬盘。那么对于其余抢不到锁的线程，我们有三种处理思路：</p>
<ul>
<li>一个线程在内存中写完一个节点就等待直到获取锁（堵塞）；</li>
<li>一个线程在内存中写完所有待处理的节点再争取锁，等待直到获取锁（堵塞）；</li>
<li>一个节点每向内存写一个节点就尝试获取锁，如果获取失败就将块加入一个队列，如果获取成功就磁盘写队列内所有的节点（非堵塞）。</li>
</ul>
<p>​        我们采取的是类似于第三种思路的并行思路：一个节点每向内存写完 MIN_BLOCK 个节点就尝试获取锁，如果获取失败就将块加入一个长为 MAX_BLOCK 的队列，如果获取成功就磁盘写队列内所有的节点（非堵塞），如果此时队列已满就进入堵塞状态。其中 MIN_BLOCK 和 MAX_BLOCK 是两个可调的参数。</p>
<p>​        最后，在我们的并行 BulkLoading 过程中，主线程会为每一层创建若干个线程，并且只有一层的所有线程执行完工作后，返回记录线程产生的一批节点键值的数组，才会开始创建上一层的线程。</p>
<h3 id="2-2-并行思路图解"><a href="#2-2-并行思路图解" class="headerlink" title="2.2 并行思路图解"></a>2.2 并行思路图解</h3><p><img src="/2022/07/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/并行设计思路.png" alt="并行设计思路.png"></p>
<h3 id="2-3-更多讨论"><a href="#2-3-更多讨论" class="headerlink" title="2.3 更多讨论"></a>2.3 更多讨论</h3><p>​        因为我们只在向内存写节点这个过程进行并行实现，而分配块号的过程是串行的，串行申请块号意味着我们无需面临块号分配不连续的问题。同时，我们每次都尽可能填满一个节点，所以也不会出现中间的叶子节点数据不满的情况。</p>
<p>​        通过我们的并行算法生成的B+树和串行生成的B+树是完全一样的，因此测试算法正确性相对简单。</p>
<h2 id="Ⅲ-算法流程图"><a href="#Ⅲ-算法流程图" class="headerlink" title="Ⅲ. 算法流程图"></a>Ⅲ. 算法流程图</h2><p><img src="/2022/07/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/算法流程图.png" alt="并行设计思路.png"></p>
<h2 id="Ⅳ-创新优化思路"><a href="#Ⅳ-创新优化思路" class="headerlink" title="Ⅳ. 创新优化思路"></a>Ⅳ. 创新优化思路</h2><h3 id="4-1-连续分配块"><a href="#4-1-连续分配块" class="headerlink" title="4.1 连续分配块"></a>4.1 连续分配块</h3><p>​        我们分离了申请块号和节点初始化两个过程，在串行阶段，我们预先使用<code>alloc_blocks</code>申请一层所需要的所有块号，再在并行阶段节点创建时调用<code>init_noalloc</code>而不是原<code>init</code>函数，此阶段无需访问磁盘申请块号。</p>
<p>​        这样做有两个好处：一是避免了多个节点并行申请块号，访问磁盘空间造成的错误，二是我们可以通过优化<code>alloc_blocks</code>过程来提高速度。</p>
<p>​        我们对申请块号的优化利用了块号连续的条件，通过修改底层，增加一次申请多个块的函数<code>append_blocks</code>，让一次申请多个连续块号只用调用一次<code>fwrite</code>，而不是每申请一个块就调用一次<code>fwrite</code>。通过这样的方法可以有效地减少<code>fwrite</code>的调用开销，提高运行速度。</p>
<p>​        相关的函数声明如下，我们在5.3节详细描述了这些函数的实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @file: block_file.h</span></span><br><span class="line"><span class="comment">// @line: 116-118</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">append_blocks</span><span class="params">( <span class="comment">// append new blocks at the end of file</span></span></span><br><span class="line"><span class="params">    Block block,	<span class="comment">// the new blocks</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> n)</span>;	</span><br><span class="line"></span><br><span class="line"><span class="comment">// @file: b_node.h</span></span><br><span class="line"><span class="comment">// @line: 36-40 </span></span><br><span class="line">virtual <span class="type">void</span> <span class="title function_">init_noalloc</span><span class="params">( <span class="comment">// init a node in menmory without allocating a block</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> level,		<span class="comment">// level in b-tree</span></span></span><br><span class="line"><span class="params">    BTree *btree,	<span class="comment">// b-tree of this node</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> block		<span class="comment">// the index of the block that pre-allocated for this node</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @file: b_tree.h</span></span><br><span class="line"><span class="comment">// @line: 92-93</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">alloc_blocks</span><span class="params">( <span class="comment">// allocate n empty blocks in the block file</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> n)</span>;		   <span class="comment">// returns an array of indexs of blocks that were allocated</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-连续写磁盘"><a href="#4-2-连续写磁盘" class="headerlink" title="4.2 连续写磁盘"></a>4.2 连续写磁盘</h3><p>​        写入磁盘的过程和像磁盘申请块号这个过程很类似，而在原代码中，节点的磁盘写入实在析构函数中实现的，即当脏位被设置为真时，析构函数回将节点内容写回磁盘。我们同样将写入磁盘这个该过程分离出来，用一个<code>write_blocks</code>函数来封装，并在执行该函数后修改节点的脏位，使其无需在析构函数中写回磁盘。</p>
<p>​        对于并行BulkLoading，每个线程负责将内容写入节点，当保存完成的节点的队列中结点的数目到达一定数目时，我们调用<code>write_leaf_blocks</code> 或 <code>write_index_blocks</code>将这些连续的节点的节点内容一次性写回磁盘。</p>
<p>​        这个过程同样利用了块号连续的特性，减少了调用<code>fwrite</code>的次数，显著地提高了运行速度。</p>
<p>​        相关的函数声明如下，我们在5.4节详细描述了这些函数的实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @file: block_file.h</span></span><br><span class="line"><span class="comment">// @line: 105-109</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">write_blocks</span><span class="params">(	<span class="comment">// write a block &lt;b&gt; in the &lt;pos&gt;</span></span></span><br><span class="line"><span class="params">    Block blocks,	<span class="comment">// a series of blocks</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> firstIndex, <span class="comment">// pos of the first block</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> n)</span>;	</span><br><span class="line"></span><br><span class="line"><span class="comment">// @file: b_tree.h</span></span><br><span class="line"><span class="comment">// @line: 96-99</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_leaf_blocks</span><span class="params">( <span class="comment">// write n blocks to the block file</span></span></span><br><span class="line"><span class="params">    BLeafNode * nodes[],</span></span><br><span class="line"><span class="params">    <span class="type">int</span> firstBlock,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @file: b_tree.h</span></span><br><span class="line"><span class="comment">// @line: 102-105</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_index_blocks</span><span class="params">( <span class="comment">// write n blocks to the block file</span></span></span><br><span class="line"><span class="params">    BIndexNode* nodes[],</span></span><br><span class="line"><span class="params">    <span class="type">int</span> firstBlock,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> n)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Ⅴ-关键代码描述"><a href="#Ⅴ-关键代码描述" class="headerlink" title="Ⅴ. 关键代码描述"></a>Ⅴ. 关键代码描述</h2><h3 id="5-1-parallelBulkLoad"><a href="#5-1-parallelBulkLoad" class="headerlink" title="5.1 parallelBulkLoad"></a>5.1 <code>parallelBulkLoad</code></h3><p>​        <code>parallelBulkLoad</code>是并行BulkLoading的创建函数，负责每次完成对一层的连续块号申请，创建和初始化并行线程来执行每一层写节点的任务，自底向上层层构建B+树。</p>
<p>​        在此之前引入线程函数的参数列表：<code>BatchLoadLeafArgs</code> 和<code>BatchLoadIndexArgs</code>，因为参数太多，他们以结构体的形式进行封装。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @file: b_tree.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">const</span> Result *hashTable;   <span class="comment">// hash table that store entries</span></span><br><span class="line">	<span class="type">int</span> entryNum;			   <span class="comment">// number of entries that the function needs to load</span></span><br><span class="line">	<span class="type">int</span> *blockIndex;		   <span class="comment">// the index of block that allocated for these entries</span></span><br><span class="line">	<span class="type">int</span> blockIndexLen;		   <span class="comment">// the length of array blockIndex</span></span><br><span class="line">	<span class="type">int</span> blockIndexStart;	   <span class="comment">// the start index of array blockIndex</span></span><br><span class="line">	<span class="type">int</span> blockIndexEnd;		   <span class="comment">// the end index of array blockIndex</span></span><br><span class="line">	<span class="type">int</span> maxBlock;			   <span class="comment">// max number of block the function can allocate</span></span><br><span class="line">	<span class="type">int</span> minBlock;			   <span class="comment">// min block num that write out</span></span><br><span class="line">	BTree *bTree;			   <span class="comment">// the btree that these nodes should belongs to</span></span><br><span class="line">	<span class="type">pthread_mutex_t</span> *fileLock; <span class="comment">// prevent multi-thread access file</span></span><br><span class="line">&#125; BatchLoadLeafArgs;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @file: b_tree.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> *sonBlockTable;		   <span class="comment">// hash table that store entries</span></span><br><span class="line">	<span class="type">float</span> *sonKeyTable;		   <span class="comment">// table that store sons&#x27; key index</span></span><br><span class="line">	<span class="type">int</span> son_num;			   <span class="comment">// the number of entries that the function needs to load</span></span><br><span class="line">	<span class="type">int</span> currentLevel;		   <span class="comment">// layers level</span></span><br><span class="line">	<span class="type">int</span> *blockIndex;		   <span class="comment">// the index of block that allocated for these entries</span></span><br><span class="line">	<span class="type">int</span> blockIndexLen;		   <span class="comment">// the length of array blockIndex</span></span><br><span class="line">	<span class="type">int</span> blockIndexStart;	   <span class="comment">// the start index of array blockIndex</span></span><br><span class="line">	<span class="type">int</span> blockIndexEnd;		   <span class="comment">// the end index of array blockIndex</span></span><br><span class="line">	<span class="type">int</span> maxBlock;			   <span class="comment">// max number of block the function can allocate</span></span><br><span class="line">	<span class="type">int</span> minBlock;			   <span class="comment">// min block num that write out</span></span><br><span class="line">	BTree *bTree;			   <span class="comment">// the btree that these nodes should belongs to</span></span><br><span class="line">	<span class="type">pthread_mutex_t</span> *fileLock; <span class="comment">// prevent multi-thread access file</span></span><br><span class="line">&#125; BatchLoadIndexArgs;</span><br></pre></td></tr></table></figure>
<p>​        <strong><code>parallelBulkLoad</code>代码及注释：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @file: b_tree.cc</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BTree::parallelBulkLoad</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">int</span> n,				 <span class="comment">// number of entries</span></span></span><br><span class="line"><span class="params">	<span class="type">const</span> Result *table, <span class="comment">// hash table</span></span></span><br><span class="line"><span class="params">	<span class="type">int</span> maxThreadNum,	 <span class="comment">// max thread num</span></span></span><br><span class="line"><span class="params">	<span class="type">int</span> maxBufferBlock	 <span class="comment">// max number of blocks in buffer</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pthread_mutex_t</span> fileLock; <span class="comment">// lock for write out</span></span><br><span class="line">	pthread_mutex_init(&amp;fileLock, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="type">int</span> threadNum = maxThreadNum;</span><br><span class="line">	<span class="type">int</span> id = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> block = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">float</span> key = MINREAL;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// get Index node and Leaf node&#x27;s capacity</span></span><br><span class="line">	<span class="type">int</span> BlockLength = this-&gt;file_-&gt;get_blocklength();</span><br><span class="line">	<span class="type">int</span> BIndexNodeCap = (BlockLength - (SIZECHAR + SIZEINT * <span class="number">3</span>)) / (SIZEFLOAT + SIZEINT);</span><br><span class="line">	<span class="type">int</span> BLeafNodeCap = (BlockLength - (SIZECHAR + SIZEINT * <span class="number">3</span>) - (<span class="type">int</span>)<span class="built_in">ceil</span>((<span class="type">float</span>)BlockLength / LEAF_NODE_SIZE) * SIZEFLOAT - SIZEINT) / SIZEINT;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// calculate the blocks number that the leaves need</span></span><br><span class="line">	<span class="type">int</span> LeafBlockNum = (<span class="type">int</span>)<span class="built_in">ceil</span>((<span class="type">double</span>)n / BLeafNodeCap);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// pre-allocate blocks for the Leaf layer</span></span><br><span class="line">	<span class="type">int</span> *LeafBlockIndex = alloc_blocks(LeafBlockNum);</span><br><span class="line">	<span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// -------------------------------------------------------------------------</span></span><br><span class="line">	<span class="comment">//  build leaf node from &lt;_hashtable&gt; (level = 0)</span></span><br><span class="line">	<span class="comment">// -------------------------------------------------------------------------</span></span><br><span class="line">	<span class="type">bool</span> firstNode = <span class="literal">true</span>; <span class="comment">// determine relationship of sibling</span></span><br><span class="line">	<span class="type">int</span> startBlock = <span class="number">0</span>;	   <span class="comment">// position of first node</span></span><br><span class="line">	<span class="type">int</span> endBlock = <span class="number">0</span>;	   <span class="comment">// position of last node</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// caluculate batch load variable</span></span><br><span class="line">	<span class="type">int</span> batchBlockSize = LeafBlockNum / threadNum;</span><br><span class="line">	<span class="type">int</span> lastBatchBlockSize = LeafBlockNum - (threadNum - <span class="number">1</span>) * batchBlockSize;</span><br><span class="line">	<span class="type">int</span> batchEntrySize = batchBlockSize * BLeafNodeCap;</span><br><span class="line">	<span class="type">int</span> lastBatchEntrySize = n - batchBlockSize * BLeafNodeCap * (threadNum - <span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> MAX_BLOCK = maxBufferBlock;</span><br><span class="line">	<span class="type">int</span> MIN_BLOCK = maxBufferBlock &gt; <span class="number">30</span> ? <span class="number">10</span> : maxBufferBlock / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// define thread and arguments for each thread</span></span><br><span class="line">	<span class="type">pthread_t</span> tid[threadNum + <span class="number">5</span>];</span><br><span class="line">	BatchLoadLeafArgs BLLA[threadNum + <span class="number">5</span>];</span><br><span class="line">	BatchLoadIndexArgs BLIA[threadNum + <span class="number">5</span>];</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// assign thread arguments for leaf node</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		BLLA[i].hashTable = table + i * batchEntrySize;</span><br><span class="line">		BLLA[i].entryNum = batchEntrySize;</span><br><span class="line">		BLLA[i].blockIndex = LeafBlockIndex;</span><br><span class="line">		BLLA[i].blockIndexLen = LeafBlockNum;</span><br><span class="line">		BLLA[i].blockIndexStart = <span class="number">0</span> + i * batchBlockSize;</span><br><span class="line">		BLLA[i].blockIndexEnd = BLLA[i].blockIndexStart + batchBlockSize - <span class="number">1</span>;</span><br><span class="line">		BLLA[i].maxBlock = MAX_BLOCK;</span><br><span class="line">		BLLA[i].minBlock = MIN_BLOCK;</span><br><span class="line">		BLLA[i].bTree = this;</span><br><span class="line">		BLLA[i].fileLock = &amp;fileLock;</span><br><span class="line">	&#125;</span><br><span class="line">	BLLA[threadNum - <span class="number">1</span>].entryNum = lastBatchEntrySize;</span><br><span class="line">	BLLA[threadNum - <span class="number">1</span>].blockIndexEnd = BLLA[threadNum - <span class="number">1</span>].blockIndexStart + lastBatchBlockSize - <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="type">float</span> *leafBlockKey = (<span class="type">float</span> *)<span class="built_in">malloc</span>(SIZEFLOAT * LeafBlockNum);</span><br><span class="line">	<span class="type">int</span> keyCount = <span class="number">0</span>;</span><br><span class="line">	<span class="type">float</span> *batchKey = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create threads for leaf node</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; threadNum; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (BLLA[i].entryNum &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			pthread_create(&amp;tid[i], <span class="literal">NULL</span>, batchLoadLeaf, &amp;(BLLA[i]));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// waiting for all threads finsihing</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (BLLA[i].entryNum &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			pthread_join(tid[i], (<span class="type">void</span> **)&amp;batchKey);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= (BLLA[i].blockIndexEnd - BLLA[i].blockIndexStart); j++)</span><br><span class="line">			&#123;</span><br><span class="line">				leafBlockKey[keyCount++] = batchKey[j];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">free</span>(batchKey);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	startBlock = LeafBlockIndex[<span class="number">0</span>];</span><br><span class="line">	endBlock = LeafBlockIndex[LeafBlockNum - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// -------------------------------------------------------------------------</span></span><br><span class="line">	<span class="comment">// build index node from bottom to top</span></span><br><span class="line">	<span class="comment">// stop condition: lastEndBlock == lastStartBlock (only one node, as root)</span></span><br><span class="line">	<span class="comment">// -------------------------------------------------------------------------</span></span><br><span class="line">	<span class="type">int</span> current_level = <span class="number">1</span>;			 <span class="comment">// current level (leaf level is 0)</span></span><br><span class="line">	<span class="type">int</span> lastStartBlock = startBlock; <span class="comment">// build b-tree level by level</span></span><br><span class="line">	<span class="type">int</span> lastEndBlock = endBlock;	 <span class="comment">// build b-tree level by level</span></span><br><span class="line">	<span class="type">float</span> *lastLayerKey = leafBlockKey;</span><br><span class="line">	<span class="type">float</span> *currentLayerKey = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> *lastLayerBlockIndex = LeafBlockIndex;</span><br><span class="line">	<span class="type">int</span> lastLayerBlockNum = LeafBlockNum;</span><br><span class="line">	<span class="type">int</span> *currentLayerBlockIndex = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> currentLayerBlockNum;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (lastEndBlock &gt; lastStartBlock)</span><br><span class="line">	&#123;</span><br><span class="line">		currentLayerBlockNum = (<span class="type">int</span>)<span class="built_in">ceil</span>((<span class="type">double</span>)lastLayerBlockNum / BIndexNodeCap);</span><br><span class="line">		currentLayerBlockIndex = alloc_blocks(currentLayerBlockNum);</span><br><span class="line">		batchBlockSize = currentLayerBlockNum / threadNum;</span><br><span class="line">		lastBatchBlockSize = currentLayerBlockNum - (threadNum - <span class="number">1</span>) * batchBlockSize;</span><br><span class="line">		batchEntrySize = batchBlockSize * BIndexNodeCap;</span><br><span class="line">		lastBatchEntrySize = lastLayerBlockNum - batchBlockSize * BIndexNodeCap * (threadNum - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// assign thread arguments</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			BLIA[i].sonBlockTable = lastLayerBlockIndex + i * batchEntrySize;</span><br><span class="line">			BLIA[i].sonKeyTable = lastLayerKey + i * batchEntrySize;</span><br><span class="line">			BLIA[i].son_num = batchEntrySize;</span><br><span class="line">			BLIA[i].currentLevel = current_level;</span><br><span class="line">			BLIA[i].blockIndex = currentLayerBlockIndex;</span><br><span class="line">			BLIA[i].blockIndexLen = currentLayerBlockNum;</span><br><span class="line">			BLIA[i].blockIndexStart = <span class="number">0</span> + i * batchBlockSize;</span><br><span class="line">			BLIA[i].blockIndexEnd = BLIA[i].blockIndexStart + batchBlockSize - <span class="number">1</span>;</span><br><span class="line">			BLIA[i].maxBlock = MAX_BLOCK;</span><br><span class="line">			BLIA[i].minBlock = MIN_BLOCK;</span><br><span class="line">			BLIA[i].bTree = this;</span><br><span class="line">			BLIA[i].fileLock = &amp;fileLock;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		BLIA[threadNum - <span class="number">1</span>].son_num = lastBatchEntrySize;</span><br><span class="line">		BLIA[threadNum - <span class="number">1</span>].blockIndexEnd = BLIA[threadNum - <span class="number">1</span>].blockIndexStart + lastBatchBlockSize - <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// create threads</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= threadNum - <span class="number">1</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (BLIA[i].son_num &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				pthread_create(&amp;tid[i], <span class="literal">NULL</span>, batchLoadIndex, &amp;(BLIA[i]));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		currentLayerKey = (<span class="type">float</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">float</span>) * (currentLayerBlockNum));</span><br><span class="line">		keyCount = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// waiting for all threads finsihing</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= threadNum - <span class="number">1</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (BLIA[i].son_num &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				pthread_join(tid[i], (<span class="type">void</span> **)&amp;batchKey);</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= (BLIA[i].blockIndexEnd - BLIA[i].blockIndexStart); j++)</span><br><span class="line">				&#123;</span><br><span class="line">					currentLayerKey[keyCount++] = batchKey[j];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">free</span>(batchKey);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		<span class="built_in">free</span>(lastLayerBlockIndex);</span><br><span class="line">		<span class="built_in">free</span>(lastLayerKey);</span><br><span class="line">		lastLayerBlockIndex = currentLayerBlockIndex;</span><br><span class="line">		lastLayerKey = currentLayerKey;</span><br><span class="line">		lastLayerBlockNum = currentLayerBlockNum;</span><br><span class="line">		lastStartBlock = currentLayerBlockIndex[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// update info</span></span><br><span class="line">		lastEndBlock = currentLayerBlockIndex[currentLayerBlockNum - <span class="number">1</span>]; </span><br><span class="line">        <span class="comment">// build b-tree of higher level</span></span><br><span class="line">		++current_level;</span><br><span class="line">		currentLayerBlockIndex = <span class="literal">NULL</span>;</span><br><span class="line">		currentLayerKey = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	assert(lastStartBlock == lastEndBlock);</span><br><span class="line">	root_ = lastStartBlock; <span class="comment">// update the &lt;root&gt;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-batchLoadLeaf-和-batchLoadIndex"><a href="#5-2-batchLoadLeaf-和-batchLoadIndex" class="headerlink" title="5.2 batchLoadLeaf 和 batchLoadIndex"></a>5.2 <code>batchLoadLeaf</code> 和 <code>batchLoadIndex</code></h3><p>​         <code>batchLoadLeaf</code> 和 <code>batchLoadIndex</code>分别是创建叶子节点的线程和创建索引节点的线程的线程函数。</p>
<p>​        线程函数的任务就是构建指定数目的节点，设置他们的左右节点，添加索引项或数据项，在获得了写文件权限后写入内存。</p>
<p>​        线程内维护了一个节点缓冲区用于保存已完成但未写入磁盘的节点，当缓冲区内节点数目大于参数 minBLOCK 时，尝试获取锁写回磁盘，当节点数目未为 maxBLOCK 时，堵塞知道获取锁然后写回磁盘。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @file: b_tree.cc</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	start routine of thread, this function wil put n entries into serveral</span></span><br><span class="line"><span class="comment">	blocks, every leaf node will be as full as possible</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">BTree::batchLoadLeaf</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// load argument structure</span></span><br><span class="line">	BatchLoadLeafArgs *funcArgs = (BatchLoadLeafArgs *)args;</span><br><span class="line">	<span class="type">const</span> Result *hashTable = funcArgs-&gt;hashTable;</span><br><span class="line">	<span class="type">int</span> entryNum = funcArgs-&gt;entryNum;</span><br><span class="line">	<span class="type">int</span> *blockIndex = funcArgs-&gt;blockIndex;</span><br><span class="line">	<span class="type">int</span> blockIndexLen = funcArgs-&gt;blockIndexLen;</span><br><span class="line">	<span class="type">int</span> blockIndexStart = funcArgs-&gt;blockIndexStart;</span><br><span class="line">	<span class="type">int</span> blockIndexEnd = funcArgs-&gt;blockIndexEnd;</span><br><span class="line">	<span class="type">int</span> maxBlock = funcArgs-&gt;maxBlock;</span><br><span class="line">	<span class="type">int</span> minBlock = funcArgs-&gt;minBlock;</span><br><span class="line">	BTree *bTree = funcArgs-&gt;bTree;</span><br><span class="line">	<span class="type">pthread_mutex_t</span> *fileLock = funcArgs-&gt;fileLock;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> *batchKey = (<span class="type">float</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">float</span>) * (blockIndexEnd - blockIndexStart + <span class="number">1</span>)); <span class="comment">// node key on the fly</span></span><br><span class="line">	<span class="type">int</span> keyCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// queue for unwrittern out blocks</span></span><br><span class="line">	BLeafNode *unWrittenBackNodeQueue[maxBlock];</span><br><span class="line">	<span class="type">int</span> queueTail = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> queuehead = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="type">float</span> key;</span><br><span class="line">	BLeafNode *currentLeafNode = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> currentBlockIndex = blockIndexStart;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= entryNum - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		assert(currentBlockIndex &lt;= blockIndexEnd);</span><br><span class="line">        <span class="comment">// get data entry </span></span><br><span class="line">		id = hashTable[i].id_;</span><br><span class="line">		key = hashTable[i].key_;</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">if</span> (currentLeafNode == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			currentLeafNode = new BLeafNode();</span><br><span class="line">			currentLeafNode-&gt;init_noalloc(<span class="number">0</span>, bTree, blockIndex[currentBlockIndex]);</span><br><span class="line">            <span class="comment">// set siblings for current node</span></span><br><span class="line">			<span class="keyword">if</span> (currentBlockIndex - <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">			&#123; <span class="comment">// has previous leaf node</span></span><br><span class="line">				currentLeafNode-&gt;set_left_sibling(blockIndex[currentBlockIndex - <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (currentBlockIndex + <span class="number">1</span> &lt;= blockIndexLen - <span class="number">1</span>)</span><br><span class="line">			&#123; <span class="comment">// has next leaf node</span></span><br><span class="line">				currentLeafNode-&gt;set_right_sibling(blockIndex[currentBlockIndex + <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// fill node with data entry</span></span><br><span class="line">		currentLeafNode-&gt;add_new_child(id, key);</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">if</span> (currentLeafNode-&gt;isFull())</span><br><span class="line">		&#123;</span><br><span class="line">			unWrittenBackNodeQueue[++queueTail] = currentLeafNode; <span class="comment">// store the leaf in memory</span></span><br><span class="line">			<span class="keyword">if</span> (queueTail &gt;= maxBlock - <span class="number">1</span>)</span><br><span class="line">			&#123;								  <span class="comment">// exceeding the max number of blocks in memory</span></span><br><span class="line">				queuehead = <span class="number">0</span>;				  <span class="comment">// points to the bottom of the stack</span></span><br><span class="line">				pthread_mutex_lock(fileLock); <span class="comment">// the thread will be suspended if the lock is occupied</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">// write out blocks that in queue if buffer in full</span></span><br><span class="line">				bTree-&gt;write_leaf_blocks(unWrittenBackNodeQueue, unWrittenBackNodeQueue[queuehead]-&gt;get_block(), queueTail + <span class="number">1</span>);</span><br><span class="line">				<span class="keyword">while</span> (queuehead &lt;= queueTail)</span><br><span class="line">				&#123;</span><br><span class="line">					batchKey[keyCount++] = unWrittenBackNodeQueue[queuehead]-&gt;get_key_of_node();</span><br><span class="line">					delete unWrittenBackNodeQueue[queuehead];</span><br><span class="line">					queuehead++;</span><br><span class="line">				&#125;</span><br><span class="line">				pthread_mutex_unlock(fileLock);</span><br><span class="line">				queueTail = <span class="number">-1</span>;</span><br><span class="line">				queuehead = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123; <span class="comment">// not exceeding the max number of blocks in memory</span></span><br><span class="line">				<span class="keyword">if</span> (queueTail + <span class="number">1</span> &gt;= minBlock)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">int</span> tryLockRes = pthread_mutex_trylock(fileLock);</span><br><span class="line">					<span class="keyword">if</span> (tryLockRes == <span class="number">0</span>)</span><br><span class="line">					&#123; <span class="comment">// the lock is free</span></span><br><span class="line">						queuehead = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">						<span class="comment">// write out blocks that in queue</span></span><br><span class="line">						bTree-&gt;write_leaf_blocks(unWrittenBackNodeQueue, unWrittenBackNodeQueue[queuehead]-&gt;get_block(), queueTail + <span class="number">1</span>);</span><br><span class="line">						<span class="keyword">while</span> (queuehead &lt;= queueTail)</span><br><span class="line">						&#123;</span><br><span class="line">							batchKey[keyCount++] = unWrittenBackNodeQueue[queuehead]-&gt;get_key_of_node();</span><br><span class="line">							delete unWrittenBackNodeQueue[queuehead];</span><br><span class="line">							queuehead++;</span><br><span class="line">						&#125;</span><br><span class="line"></span><br><span class="line">						pthread_mutex_unlock(fileLock);</span><br><span class="line">						queueTail = <span class="number">-1</span>;</span><br><span class="line">						queuehead = <span class="number">0</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			currentLeafNode = <span class="literal">NULL</span>;</span><br><span class="line">			currentBlockIndex++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (currentLeafNode != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		unWrittenBackNodeQueue[++queueTail] = currentLeafNode; <span class="comment">// store the leaf in memory</span></span><br><span class="line">	&#125;</span><br><span class="line">	pthread_mutex_lock(fileLock); <span class="comment">// the thread will be suspended if the lock is occupied</span></span><br><span class="line">	queuehead = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// write out blocks that in queue if queue in not empty</span></span><br><span class="line">	bTree-&gt;write_leaf_blocks(unWrittenBackNodeQueue, unWrittenBackNodeQueue[queuehead]-&gt;get_block(), queueTail + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span> (queuehead &lt;= queueTail)</span><br><span class="line">	&#123;</span><br><span class="line">		batchKey[keyCount++] = unWrittenBackNodeQueue[queuehead]-&gt;get_key_of_node();</span><br><span class="line">		delete unWrittenBackNodeQueue[queuehead];</span><br><span class="line">		queuehead++;</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_mutex_unlock(fileLock);</span><br><span class="line">	queueTail = <span class="number">-1</span>;</span><br><span class="line">	queuehead = <span class="number">0</span>;</span><br><span class="line">	assert(keyCount == blockIndexEnd - blockIndexStart + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> batchKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @file: b_tree.cc</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">BTree::batchLoadIndex</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// load argument structure</span></span><br><span class="line">	BatchLoadIndexArgs *funcArgs = (BatchLoadIndexArgs *)args;</span><br><span class="line">	<span class="type">int</span> *sonBlockTable = funcArgs-&gt;sonBlockTable;</span><br><span class="line">	<span class="type">float</span> *sonKeyTable = funcArgs-&gt;sonKeyTable;	</span><br><span class="line">	<span class="type">int</span> son_num = funcArgs-&gt;son_num;	</span><br><span class="line">	<span class="type">int</span> *blockIndex = funcArgs-&gt;blockIndex;	</span><br><span class="line">	<span class="type">int</span> currentLevel = funcArgs-&gt;currentLevel;	</span><br><span class="line">	<span class="type">int</span> blockIndexLen = funcArgs-&gt;blockIndexLen;</span><br><span class="line">	<span class="type">int</span> blockIndexStart = funcArgs-&gt;blockIndexStart; </span><br><span class="line">	<span class="type">int</span> blockIndexEnd = funcArgs-&gt;blockIndexEnd;</span><br><span class="line">	<span class="type">int</span> maxBlock = funcArgs-&gt;maxBlock;		</span><br><span class="line">	<span class="type">int</span> minBlock = funcArgs-&gt;minBlock;		</span><br><span class="line">	BTree *bTree = funcArgs-&gt;bTree;			</span><br><span class="line">	<span class="type">pthread_mutex_t</span> *fileLock = funcArgs-&gt;fileLock;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> block;</span><br><span class="line">	<span class="type">float</span> key;</span><br><span class="line">	BIndexNode *currentIndexNode = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> currentBlockIndex = blockIndexStart;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// queue for unwrittern out blocks</span></span><br><span class="line">	BIndexNode *unWrittenBackNodeQueue[maxBlock];</span><br><span class="line">	<span class="type">int</span> queueTail = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> lockRet;</span><br><span class="line">	<span class="type">int</span> queuehead = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> *batchKey = (<span class="type">float</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">float</span>) * (blockIndexEnd - blockIndexStart + <span class="number">1</span>)); <span class="comment">// node key on the fly</span></span><br><span class="line">	<span class="type">int</span> keyCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= son_num - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		block = sonBlockTable[i]; <span class="comment">// get &lt;block&gt;</span></span><br><span class="line">		key = sonKeyTable[i];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (currentIndexNode == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			currentIndexNode = new BIndexNode();</span><br><span class="line">			currentIndexNode-&gt;init_noalloc(currentLevel, bTree, blockIndex[currentBlockIndex]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// set siblings for current node</span></span><br><span class="line">			<span class="keyword">if</span> (currentBlockIndex - <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">				currentIndexNode-&gt;set_left_sibling(blockIndex[currentBlockIndex - <span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">if</span> (currentBlockIndex + <span class="number">1</span> &lt;= blockIndexLen - <span class="number">1</span>)</span><br><span class="line">				currentIndexNode-&gt;set_right_sibling(blockIndex[currentBlockIndex + <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		currentIndexNode-&gt;add_new_child(key, block); <span class="comment">// add new entry</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (currentIndexNode-&gt;isFull())</span><br><span class="line">		&#123;</span><br><span class="line">			unWrittenBackNodeQueue[++queueTail] = currentIndexNode;</span><br><span class="line">			<span class="keyword">if</span> (queueTail &gt;= maxBlock - <span class="number">1</span>)</span><br><span class="line">			&#123; <span class="comment">// the buffer is full. Have to write these nodes out</span></span><br><span class="line">				pthread_mutex_lock(fileLock);</span><br><span class="line">				queuehead = <span class="number">0</span>;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// write out blocks that in queue if buffer is full</span></span><br><span class="line">				bTree-&gt;write_index_blocks(unWrittenBackNodeQueue, unWrittenBackNodeQueue[queuehead]-&gt;get_block(), \</span><br><span class="line">                                          queueTail + <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">				<span class="keyword">while</span> (queuehead &lt;= queueTail)</span><br><span class="line">				&#123;</span><br><span class="line">					batchKey[keyCount++] = unWrittenBackNodeQueue[queuehead]-&gt;get_key_of_node();</span><br><span class="line">					delete unWrittenBackNodeQueue[queuehead];</span><br><span class="line">					queuehead++;</span><br><span class="line">				&#125;</span><br><span class="line">				pthread_mutex_unlock(fileLock);</span><br><span class="line">				queueTail = <span class="number">-1</span>;</span><br><span class="line">				queuehead = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (queueTail + <span class="number">1</span> &gt;= minBlock)</span><br><span class="line">				&#123;</span><br><span class="line">					lockRet = pthread_mutex_trylock(fileLock);</span><br><span class="line">					<span class="keyword">if</span> (lockRet == <span class="number">0</span>)</span><br><span class="line">					&#123; <span class="comment">// the lock is free</span></span><br><span class="line">						queuehead = <span class="number">0</span>;</span><br><span class="line">						</span><br><span class="line">						<span class="comment">// write out blocks that in queue</span></span><br><span class="line">						bTree-&gt;write_index_blocks(unWrittenBackNodeQueue, unWrittenBackNodeQueue[queuehead]-&gt;get_block(), \</span><br><span class="line">                                                  queueTail + <span class="number">1</span>);</span><br><span class="line">						<span class="keyword">while</span> (queuehead &lt;= queueTail)</span><br><span class="line">						&#123;</span><br><span class="line">							batchKey[keyCount++] = unWrittenBackNodeQueue[queuehead]-&gt;get_key_of_node();</span><br><span class="line">							delete unWrittenBackNodeQueue[queuehead];</span><br><span class="line">							queuehead++;</span><br><span class="line">						&#125;</span><br><span class="line">						pthread_mutex_unlock(fileLock);</span><br><span class="line">						queueTail = <span class="number">-1</span>;</span><br><span class="line">						queuehead = <span class="number">0</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			currentIndexNode = <span class="literal">NULL</span>;</span><br><span class="line">			currentBlockIndex++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (currentIndexNode != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		unWrittenBackNodeQueue[++queueTail] = currentIndexNode;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// write out blocks that in queue if queue in not empty</span></span><br><span class="line">	pthread_mutex_lock(fileLock);</span><br><span class="line">	queuehead = <span class="number">0</span>;</span><br><span class="line">	bTree-&gt;write_index_blocks(unWrittenBackNodeQueue, unWrittenBackNodeQueue[queuehead]-&gt;get_block(), queueTail + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span> (queuehead &lt;= queueTail)</span><br><span class="line">	&#123;</span><br><span class="line">		batchKey[keyCount++] = unWrittenBackNodeQueue[queuehead]-&gt;get_key_of_node();</span><br><span class="line">		delete unWrittenBackNodeQueue[queuehead];</span><br><span class="line">		queuehead++;</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_mutex_unlock(fileLock);</span><br><span class="line">	queueTail = <span class="number">-1</span>;</span><br><span class="line">	queuehead = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">	assert(keyCount == blockIndexEnd - blockIndexStart + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> batchKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-append-blocks、init-noalloc-和-alloc-blocks"><a href="#5-3-append-blocks、init-noalloc-和-alloc-blocks" class="headerlink" title="5.3 append_blocks、init_noalloc 和  alloc_blocks"></a>5.3 <code>append_blocks</code>、<code>init_noalloc</code> 和  <code>alloc_blocks</code></h3><p>优化代码一：连续分配块过程对<code>blockfile</code>、<code>b_node</code>和<code>b_tree</code>的修改，优化思路已在4.1节中描述。</p>
<p>BlockFile中连续块号申请的底层实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @file: blockfile.cc</span></span><br><span class="line"><span class="comment">// append a series of blocks(cont), avoid calling fwrite too often</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">BlockFile::append_blocks</span><span class="params">(		<span class="comment">// append new block at the end of file</span></span></span><br><span class="line"><span class="params">	Block block,					<span class="comment">// the new blocks</span></span></span><br><span class="line"><span class="params">	<span class="type">int</span> n)</span>							<span class="comment">// the number of blocks</span></span><br><span class="line">&#123;</span><br><span class="line">	fseek(fp_, <span class="number">0</span>, SEEK_END);		<span class="comment">// &lt;fp_&gt; point to the end of file</span></span><br><span class="line">	fwrite(block, n, block_length_, fp_);</span><br><span class="line">	<span class="type">int</span> start_block = num_blocks_;</span><br><span class="line">	num_blocks_ += n;					<span class="comment">// add 1 to &lt;num_blocks_&gt;</span></span><br><span class="line">	</span><br><span class="line">	fseek(fp_, SIZEINT, SEEK_SET);	<span class="comment">// &lt;fp_&gt; point to pos of header</span></span><br><span class="line">	fwrite_number(num_blocks_);		<span class="comment">// update &lt;num_blocks_&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// -------------------------------------------------------------------------</span></span><br><span class="line">	<span class="comment">//  &lt;fp_&gt; point to the pos of new added block. </span></span><br><span class="line">	<span class="comment">//  the equation &lt;act_block_&gt; = &lt;num_blocks_&gt; indicates the file pointer </span></span><br><span class="line">	<span class="comment">//  point to new added block.</span></span><br><span class="line">	<span class="comment">//  return index of new added block</span></span><br><span class="line">	<span class="comment">// -------------------------------------------------------------------------</span></span><br><span class="line">	fseek(fp_, -block_length_, SEEK_END);</span><br><span class="line">	act_block_ = num_blocks_;</span><br><span class="line">	<span class="type">int</span>* blockIndex = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		blockIndex[i] = start_block + i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> blockIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>init_noalloc</code>函数的实现包括：BNode的实现、BIndexNode的重载和BLeafNode的重载。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @file: b_node.cc</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BNode::init_noalloc</span><span class="params">( <span class="comment">// init a new node in menmory without allocating a block</span></span></span><br><span class="line"><span class="params">	<span class="type">int</span> level,			  <span class="comment">// level in b-tree</span></span></span><br><span class="line"><span class="params">	BTree *btree,		  <span class="comment">// b-tree of this node</span></span></span><br><span class="line"><span class="params">	<span class="type">int</span> block			  <span class="comment">// the index of the block that pre-allocated for this node</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	btree_ = btree;</span><br><span class="line">	level_ = (<span class="type">char</span>)level;</span><br><span class="line">	dirty_ = <span class="literal">true</span>;</span><br><span class="line">	left_sibling_ = <span class="number">-1</span>;</span><br><span class="line">	right_sibling_ = <span class="number">-1</span>;</span><br><span class="line">	key_ = <span class="literal">NULL</span>;</span><br><span class="line">	num_entries_ = <span class="number">0</span>;</span><br><span class="line">	block_ = block; <span class="comment">// differnet with BNode::init</span></span><br><span class="line">	capacity_ = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @file: b_node.cc</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BIndexNode::init_noalloc</span><span class="params">( <span class="comment">// init a new node in menmory without allocating a block</span></span></span><br><span class="line"><span class="params">	<span class="type">int</span> level,				   <span class="comment">// level in b-tree</span></span></span><br><span class="line"><span class="params">	BTree *btree,			   <span class="comment">// b-tree of this node</span></span></span><br><span class="line"><span class="params">	<span class="type">int</span> block				   <span class="comment">// the index of the block that pre-allocated for this node</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	btree_ = btree;</span><br><span class="line">	level_ = (<span class="type">char</span>)level;</span><br><span class="line">	block_ = block;</span><br><span class="line">	num_entries_ = <span class="number">0</span>;</span><br><span class="line">	left_sibling_ = <span class="number">-1</span>;</span><br><span class="line">	right_sibling_ = <span class="number">-1</span>;</span><br><span class="line">	dirty_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> b_length = btree_-&gt;file_-&gt;get_blocklength();</span><br><span class="line">	capacity_ = (b_length - get_header_size()) / get_entry_size();</span><br><span class="line">	<span class="keyword">if</span> (capacity_ &lt; <span class="number">50</span>)</span><br><span class="line">	&#123; <span class="comment">// ensure at least 50 entries</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;capacity = %d, which is too small.\n&quot;</span>, capacity_);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	key_ = new <span class="type">float</span>[capacity_];</span><br><span class="line">	son_ = new <span class="type">int</span>[capacity_];</span><br><span class="line">	<span class="comment">// alloc memory</span></span><br><span class="line">	<span class="built_in">memset</span>(key_, MINREAL, capacity_ * SIZEFLOAT);</span><br><span class="line">	<span class="built_in">memset</span>(son_, <span class="number">-1</span>, capacity_ * SIZEINT);</span><br><span class="line">	<span class="comment">// whithout allocating block in the file</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @file: b_node.cc</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BLeafNode::init_noalloc</span><span class="params">( <span class="comment">//init a new node in menmory without allocating a block</span></span></span><br><span class="line"><span class="params">	<span class="type">int</span> level,				  <span class="comment">// level in b-tree</span></span></span><br><span class="line"><span class="params">	BTree *btree,			  <span class="comment">// b-tree of this node</span></span></span><br><span class="line"><span class="params">	<span class="type">int</span> block				  <span class="comment">// the index of the block that pre-allocated for this node</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	btree_ = btree;</span><br><span class="line">	level_ = (<span class="type">char</span>)level;</span><br><span class="line">	block_ = block;</span><br><span class="line">	num_entries_ = <span class="number">0</span>;</span><br><span class="line">	num_keys_ = <span class="number">0</span>;</span><br><span class="line">	left_sibling_ = <span class="number">-1</span>;</span><br><span class="line">	right_sibling_ = <span class="number">-1</span>;</span><br><span class="line">	dirty_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> b_length = btree_-&gt;file_-&gt;get_blocklength();</span><br><span class="line">	<span class="type">int</span> key_size = get_key_size(b_length);</span><br><span class="line"></span><br><span class="line">	key_ = new <span class="type">float</span>[capacity_keys_];</span><br><span class="line">	<span class="built_in">memset</span>(key_, MINREAL, capacity_keys_ * SIZEFLOAT);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> header_size = get_header_size();</span><br><span class="line">	<span class="type">int</span> entry_size = get_entry_size();</span><br><span class="line"></span><br><span class="line">	capacity_ = (b_length - header_size - key_size) / entry_size;</span><br><span class="line">	<span class="keyword">if</span> (capacity_ &lt; <span class="number">100</span>)</span><br><span class="line">	&#123; <span class="comment">// at least 100 entries</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;capacity = %d, which is too small.\n&quot;</span>, capacity_);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	id_ = new <span class="type">int</span>[capacity_];</span><br><span class="line">	<span class="built_in">memset</span>(id_, <span class="number">-1</span>, capacity_ * SIZEINT);</span><br><span class="line">	<span class="comment">// whithout allocating block in the file</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BTree中的连续块分配方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @file: b_tree.cc</span></span><br><span class="line"><span class="type">int</span> *<span class="title function_">BTree::alloc_blocks</span><span class="params">( <span class="comment">// allocate n empty blocks in the block file</span></span></span><br><span class="line"><span class="params">	<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *randomBlk = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (this-&gt;file_-&gt;get_blocklength()) * n); </span><br><span class="line">    <span class="comment">// an useless block, just to fill the file</span></span><br><span class="line">	<span class="type">int</span> *blockIndexs = this-&gt;file_-&gt;append_blocks(randomBlk, n);</span><br><span class="line">	<span class="keyword">return</span> blockIndexs;</span><br><span class="line">&#125; <span class="comment">// returns an array of indexs of blocks that were allocated</span></span><br></pre></td></tr></table></figure>
<h3 id="5-4-write-blocks、write-leaf-blocks-和-write-index-blocks"><a href="#5-4-write-blocks、write-leaf-blocks-和-write-index-blocks" class="headerlink" title="5.4 write_blocks、write_leaf_blocks 和 write_index_blocks"></a>5.4 <code>write_blocks</code>、<code>write_leaf_blocks</code> 和 <code>write_index_blocks</code></h3><p>优化代码二：连续分配块过程对<code>blockfile</code>和<code>b_tree</code>的修改，优化思路已在4.2节中描述。</p>
<p>BlockFile中连续块写入的底层实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @file: blockfile.cc</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">BlockFile::write_blocks</span><span class="params">(	<span class="comment">// write a block &lt;b&gt; in the &lt;pos&gt;</span></span></span><br><span class="line"><span class="params">	Block blocks,	<span class="comment">// a series of blocks</span></span></span><br><span class="line"><span class="params">	<span class="type">int</span> firstBlock, <span class="comment">// pos of the first block</span></span></span><br><span class="line"><span class="params">	<span class="type">int</span> n)</span>			<span class="comment">// block num</span></span><br><span class="line">&#123;</span><br><span class="line">	firstBlock++;</span><br><span class="line">	fseek(fp_, block_length_ * firstBlock, SEEK_SET);</span><br><span class="line">	fwrite(blocks, block_length_, n, fp_);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (firstBlock + n &gt; num_blocks_) &#123;	<span class="comment">// update &lt;act_block_&gt;</span></span><br><span class="line">		fseek(fp_, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">		act_block_ = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		act_block_ = firstBlock + n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BTree 中 <code>write_leaf_blocks</code> 和 <code>write_index_blocks</code> 的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @file: b_tree.cc</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BTree::write_leaf_blocks</span><span class="params">( <span class="comment">// write n blocks to the block file</span></span></span><br><span class="line"><span class="params">	BLeafNode* nodes[], <span class="comment">// array of leaf node&#x27;s info</span></span></span><br><span class="line"><span class="params">	<span class="type">int</span> firstBlock,		<span class="comment">// first block num</span></span></span><br><span class="line"><span class="params">	<span class="type">int</span> n)</span>				<span class="comment">// total block num</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> block_length = file_-&gt;get_blocklength();</span><br><span class="line">	<span class="type">char</span>* blocksContent = new <span class="type">char</span>[block_length * n];</span><br><span class="line">	<span class="type">int</span> ptr = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// merge all the blocks content into a buffer</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="type">char</span> *buf = new <span class="type">char</span>[block_length];</span><br><span class="line">		nodes[i]-&gt;write_to_buffer(buf);</span><br><span class="line">		nodes[i]-&gt;set_dirty(<span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; block_length; j++)&#123;</span><br><span class="line">			blocksContent[ptr++] = buf[j];</span><br><span class="line">		&#125;</span><br><span class="line">		delete[] buf;</span><br><span class="line">		buf = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	this-&gt;file_-&gt;write_blocks(blocksContent, firstBlock, n);</span><br><span class="line">	delete[] blocksContent;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// @file: b_tree.cc</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BTree::write_index_blocks</span><span class="params">( <span class="comment">// write n blocks to the block file</span></span></span><br><span class="line"><span class="params">	BIndexNode* nodes[], 	<span class="comment">// array of index node&#x27;s info</span></span></span><br><span class="line"><span class="params">	<span class="type">int</span> firstBlock,			<span class="comment">// first block num</span></span></span><br><span class="line"><span class="params">	<span class="type">int</span> n)</span>					<span class="comment">// total block num</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> block_length = file_-&gt;get_blocklength();</span><br><span class="line">	<span class="type">char</span>* blocksContent = new <span class="type">char</span>[block_length * n];</span><br><span class="line">	<span class="type">int</span> ptr = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// merge all the blocks content into a buffer</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="type">char</span> *buf = new <span class="type">char</span>[block_length];</span><br><span class="line">		nodes[i]-&gt;write_to_buffer(buf);</span><br><span class="line">		nodes[i]-&gt;set_dirty(<span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; block_length; j++)&#123;</span><br><span class="line">			blocksContent[ptr++] = buf[j];</span><br><span class="line">		&#125;</span><br><span class="line">		delete[] buf;</span><br><span class="line">		buf = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	this-&gt;file_-&gt;write_blocks(blocksContent, firstBlock, n);</span><br><span class="line">	delete[] blocksContent;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="5-5-write-B-tree"><a href="#5-5-write-B-tree" class="headerlink" title="5.5 write_B_tree"></a>5.5 <code>write_B_tree</code></h3><p> <code>write_B_tree</code>：用于判断传并行产生的B+树是否一致，以此来对算法进行正确性测试。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @file: main.cc</span></span><br><span class="line"><span class="comment">// print B_Tree and store it in file</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_B_Tree</span><span class="params">(BTree *trees_, <span class="type">char</span> *filename)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = fopen(filename, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;File can not open!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> start_block = trees_-&gt;root_;</span><br><span class="line">    <span class="type">int</span> end_block = trees_-&gt;root_;</span><br><span class="line">    <span class="type">int</span> newly_startblock;</span><br><span class="line">    <span class="type">int</span> newly_endblock;</span><br><span class="line"></span><br><span class="line">    BIndexNode *index_child = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read root node</span></span><br><span class="line">    <span class="type">char</span> indexnode_level;</span><br><span class="line">    <span class="type">int</span> indexnode_num_entries;</span><br><span class="line">    BIndexNode *indexnode_left_sibling;</span><br><span class="line">    BIndexNode *indexnode_right_sibling;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;root: block %d\n&quot;</span>, start_block);</span><br><span class="line">    index_child = new BIndexNode();</span><br><span class="line">    index_child-&gt;init_restore(trees_, start_block);</span><br><span class="line">    indexnode_level = index_child-&gt;get_level();</span><br><span class="line">    indexnode_num_entries = index_child-&gt;get_num_entries();</span><br><span class="line">    indexnode_left_sibling = index_child-&gt;get_left_sibling();</span><br><span class="line">    indexnode_right_sibling = index_child-&gt;get_right_sibling();</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;\tlevel: %d \tnum_entries: %d\n&quot;</span>, indexnode_level, indexnode_num_entries);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; indexnode_num_entries; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">&quot;\t\tkey: %f\tson: %d\n&quot;</span>, index_child-&gt;get_key(j), index_child-&gt;get_son(j));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    start_block = index_child-&gt;get_son(<span class="number">0</span>);</span><br><span class="line">    end_block = index_child-&gt;get_son(indexnode_num_entries - <span class="number">1</span>);</span><br><span class="line">    delete index_child;</span><br><span class="line">    index_child = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// index node</span></span><br><span class="line">    <span class="comment">// from root to the leaf layer to layer</span></span><br><span class="line">    <span class="keyword">while</span> (start_block &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = start_block; k &lt;= end_block; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">&quot;index: block %d\n&quot;</span>, k);</span><br><span class="line">            index_child = new BIndexNode();</span><br><span class="line">            index_child-&gt;init_restore(trees_, k);</span><br><span class="line">            indexnode_level = index_child-&gt;get_level();</span><br><span class="line">            indexnode_num_entries = index_child-&gt;get_num_entries();</span><br><span class="line">            indexnode_left_sibling = index_child-&gt;get_left_sibling();</span><br><span class="line">            indexnode_right_sibling = index_child-&gt;get_right_sibling();</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">&quot;\tlevel: %d \tnum_entries: %d\n&quot;</span>, indexnode_level, indexnode_num_entries);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; indexnode_num_entries; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(fp, <span class="string">&quot;\t\tkey: %f\tson: %d\n&quot;</span>, index_child-&gt;get_key(j), index_child-&gt;get_son(j));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == start_block)</span><br><span class="line">            &#123;</span><br><span class="line">                newly_startblock = index_child-&gt;get_son(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == end_block)</span><br><span class="line">            &#123;</span><br><span class="line">                newly_endblock = index_child-&gt;get_son(indexnode_num_entries - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            delete index_child;</span><br><span class="line">            index_child = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="comment">// end for loop</span></span><br><span class="line">        start_block = newly_startblock;</span><br><span class="line">        end_block = newly_endblock;</span><br><span class="line">    &#125; <span class="comment">// end while</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// leaf node variable</span></span><br><span class="line">    BLeafNode *leaf_child = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read root node</span></span><br><span class="line">    <span class="type">char</span> leafnode_level;</span><br><span class="line">    <span class="type">int</span> leafnode_num_entries;</span><br><span class="line">    <span class="type">int</span> leafnode_num_keys;</span><br><span class="line">    BLeafNode *leafnode_left_sibling;</span><br><span class="line">    BLeafNode *leafnode_right_sibling;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print leaf node</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = start_block; k &lt;= end_block; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">&quot;leaf: block %d\n&quot;</span>, k);</span><br><span class="line">        leaf_child = new BLeafNode();</span><br><span class="line">        leaf_child-&gt;init_restore(trees_, k);</span><br><span class="line">        leafnode_level = leaf_child-&gt;get_level();</span><br><span class="line">        leafnode_num_entries = leaf_child-&gt;get_num_entries();</span><br><span class="line">        leafnode_left_sibling = leaf_child-&gt;get_left_sibling();</span><br><span class="line">        leafnode_right_sibling = leaf_child-&gt;get_right_sibling();</span><br><span class="line">        leafnode_num_keys = leaf_child-&gt;get_num_keys();</span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">&quot;\tlevel: %d \tnum_entries: %d\tnum_keys: %d\n&quot;</span>, leafnode_level, leafnode_num_entries, leafnode_num_keys);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; leafnode_num_keys; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> count_entries = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">&quot;\t\tkey: %f\n&quot;</span>, leaf_child-&gt;get_key(j));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> w = count_entries; w &lt; <span class="built_in">std</span>::min(count_entries + <span class="number">16</span>, leafnode_num_entries); w++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(fp, <span class="string">&quot;\t\t\tid: %d\n&quot;</span>, leaf_child-&gt;get_entry_id(w));</span><br><span class="line">            &#125;</span><br><span class="line">            count_entries += <span class="number">16</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        delete leaf_child;</span><br><span class="line">        leaf_child = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Ⅵ-实验结果分析"><a href="#Ⅵ-实验结果分析" class="headerlink" title="Ⅵ. 实验结果分析"></a>Ⅵ. 实验结果分析</h2><h3 id="6-0-并行和性能调优的代码说明"><a href="#6-0-并行和性能调优的代码说明" class="headerlink" title="6.0 并行和性能调优的代码说明"></a>6.0 并行和性能调优的代码说明</h3><p>由于我们提交的代码是将并行和性能调优一起使用的代码，因此在这里有必要说明改到只有并行处理的方式。同时说明一下如何测试代码。</p>
<h4 id="6-0-1-改为非连续写磁盘的方式"><a href="#6-0-1-改为非连续写磁盘的方式" class="headerlink" title="6.0.1 改为非连续写磁盘的方式"></a>6.0.1 改为非连续写磁盘的方式</h4><ul>
<li>将<code>batchLoadLeaf</code>函数的<code>//DO</code>处标记的函数<code>write_leaf_blocks</code>注释掉。</li>
<li>将<code>batchLoadIndex</code>函数的<code>//DO</code>处标记的函数<code>write_index_blocks</code>注释掉。</li>
</ul>
<h4 id="6-0-2-改为非连续分配块的方式"><a href="#6-0-2-改为非连续分配块的方式" class="headerlink" title="6.0.2 改为非连续分配块的方式"></a>6.0.2 改为非连续分配块的方式</h4><ol>
<li><p>将<code>int *BTree::alloc_blocks(int n)</code>函数的前两行注释掉</p>
</li>
<li><p>并添加如下几行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *blockIndexs = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="type">char</span> *randomBlk = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (this-&gt;file_-&gt;get_blocklength())); </span><br><span class="line">		blockIndexs[i] = this-&gt;file_-&gt;append_block(randomBlk);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="6-0-3-如何测试代码"><a href="#6-0-3-如何测试代码" class="headerlink" title="6.0.3 如何测试代码"></a>6.0.3 如何测试代码</h4><ol>
<li>将<code>main.cc</code>文件的<code>evaluate()</code>函数的注释去掉</li>
<li>使用命令<code>sh run.sh</code>运行脚本文件</li>
</ol>
<h3 id="6-1-并行实验结果代码及分析"><a href="#6-1-并行实验结果代码及分析" class="headerlink" title="6.1 并行实验结果代码及分析"></a>6.1 并行实验结果代码及分析</h3><p><strong>注：为保证实验的准确性和有效性，排除CPU此时的运行情况和内存情况以及其他进程的影响，我们测试的实验结果都是采用10次实验结果取平均得到的结果，并且使用Python绘图来让结果可视化。</strong></p>
<h4 id="6-1-1-影响因素"><a href="#6-1-1-影响因素" class="headerlink" title="6.1.1 影响因素"></a>6.1.1 影响因素</h4><p>并行处理函数的参数就包含了我们的所要分析的影响因素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BTree::parallelBulkLoad</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">int</span> n,				 <span class="comment">// number of entries</span></span></span><br><span class="line"><span class="params">	<span class="type">const</span> Result *table, <span class="comment">// hash table</span></span></span><br><span class="line"><span class="params">	<span class="type">int</span> maxThreadNum,	 <span class="comment">// max thread num</span></span></span><br><span class="line"><span class="params">	<span class="type">int</span> maxBufferBlock	 <span class="comment">// max number of blocks in buffer</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>
<p>这里面除了<code>table</code>变量是数据集外，其他3个变量即数据项的数目，最大的线程数，Buffer的大小，都是我们需要考虑的因素。</p>
<p>这里我们并没有改变Block的大小，默认仍是512个字节。</p>
<h4 id="6-1-2-实验方法"><a href="#6-1-2-实验方法" class="headerlink" title="6.1.2 实验方法"></a>6.1.2 实验方法</h4><p>我们采用<strong>控制变量法</strong>的方式，先确定好其他两个变量的默认值，再去改变其他变量。</p>
<p>3个变量的默认值如下：</p>
<ul>
<li>线程数目：2</li>
<li>数据项的数目：1000000</li>
<li>Buffer的大小：500个Block</li>
</ul>
<h4 id="6-1-3-数据项的数目int-n"><a href="#6-1-3-数据项的数目int-n" class="headerlink" title="6.1.3 数据项的数目int n"></a>6.1.3 数据项的数目<code>int n</code></h4><p><strong>测试代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> entryNum[] = &#123;<span class="number">100</span>,<span class="number">1000</span>,<span class="number">10000</span>,<span class="number">100000</span>,<span class="number">1000000</span>,<span class="number">10000000</span>&#125;;</span><br><span class="line">outFile.open(<span class="string">&quot;./result/result_entryNum.csv&quot;</span>, ios::out);</span><br><span class="line">   outFile&lt;&lt;<span class="string">&quot;entryNum  sertime  partime&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;结果存放于./result/result_entryNum.csv\n&quot;</span>);</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">6</span>;++i)&#123;</span><br><span class="line">       <span class="type">float</span> entry_run1 = <span class="number">0</span>;</span><br><span class="line">       <span class="type">float</span> entry_run2 = <span class="number">0</span>;</span><br><span class="line">       make_data(entryNum[i]);</span><br><span class="line"></span><br><span class="line">       <span class="built_in">strncpy</span>(data_file, <span class="string">&quot;./data/dataset.csv&quot;</span>, <span class="keyword">sizeof</span>(data_file));</span><br><span class="line">       <span class="built_in">strncpy</span>(tree_file_ser, <span class="string">&quot;./result/B_tree_ser&quot;</span>, <span class="keyword">sizeof</span>(tree_file_ser));</span><br><span class="line">       <span class="built_in">strncpy</span>(tree_file_par, <span class="string">&quot;./result/B_tree_par&quot;</span>, <span class="keyword">sizeof</span>(tree_file_par));</span><br><span class="line"></span><br><span class="line">       Result *table = new Result[entryNum[i]]; </span><br><span class="line"></span><br><span class="line">       ifstream <span class="title function_">fp</span><span class="params">(data_file)</span>; </span><br><span class="line">       <span class="built_in">string</span> line;</span><br><span class="line">       <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (getline(fp,line) &amp;&amp; k &lt;= entryNum[i] - <span class="number">1</span>)&#123; </span><br><span class="line">           <span class="built_in">string</span> number;</span><br><span class="line">           <span class="built_in">istringstream</span> <span class="title function_">readstr</span><span class="params">(line)</span>; </span><br><span class="line">           </span><br><span class="line">           getline(readstr,number,<span class="string">&#x27;,&#x27;</span>); </span><br><span class="line">           table[k].key_ = atof(number.c_str()); </span><br><span class="line"></span><br><span class="line">           getline(readstr,number,<span class="string">&#x27;,&#x27;</span>); </span><br><span class="line">           table[k].id_ = atoi(number.c_str());    </span><br><span class="line">           k++;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       fp.close();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> w = <span class="number">0</span>; w &lt; AVERAGE_NUM; w++) &#123;</span><br><span class="line">           timeval <span class="type">start_t</span>;  </span><br><span class="line">           timeval <span class="type">end_t</span>;</span><br><span class="line"></span><br><span class="line">           BTree* trees_ = new BTree();</span><br><span class="line">           trees_-&gt;init(B_, tree_file_ser);</span><br><span class="line">           gettimeofday(&amp;<span class="type">start_t</span>,<span class="literal">NULL</span>);</span><br><span class="line">       </span><br><span class="line">           <span class="keyword">if</span> (trees_-&gt;bulkload(entryNum[i], table)) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">           gettimeofday(&amp;<span class="type">end_t</span>, <span class="literal">NULL</span>);</span><br><span class="line">           <span class="type">float</span> run_t1 = <span class="type">end_t</span>.tv_sec - <span class="type">start_t</span>.tv_sec + </span><br><span class="line">                           (<span class="type">end_t</span>.tv_usec - <span class="type">start_t</span>.tv_usec) / <span class="number">1000000.0f</span>;</span><br><span class="line">           <span class="comment">//printf(&quot;串行运行时间: %f  s\n&quot;, run_t1);</span></span><br><span class="line">           delete trees_;</span><br><span class="line">           <span class="comment">//-------------------------------------------------------------------------------</span></span><br><span class="line">           trees_ = new BTree();</span><br><span class="line">       </span><br><span class="line">           trees_-&gt;init(B_, tree_file_par);</span><br><span class="line">           gettimeofday(&amp;<span class="type">start_t</span>,<span class="literal">NULL</span>);</span><br><span class="line">       </span><br><span class="line">           <span class="keyword">if</span> (trees_-&gt;parallelBulkLoad(entryNum[i], table, DEFAULT_THREAD_NUM, DEFAULT_BUFFER_SIZE)) <span class="keyword">return</span> ;</span><br><span class="line">           gettimeofday(&amp;<span class="type">end_t</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">           <span class="type">float</span> run_t2 = <span class="type">end_t</span>.tv_sec - <span class="type">start_t</span>.tv_sec + </span><br><span class="line">                               (<span class="type">end_t</span>.tv_usec - <span class="type">start_t</span>.tv_usec) / <span class="number">1000000.0f</span>;</span><br><span class="line">           <span class="comment">//printf(&quot;并行运行时间: %f  s\n&quot;, run_t1);</span></span><br><span class="line">           entry_run1 += run_t1;</span><br><span class="line">           entry_run2 += run_t2;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span>(table != <span class="literal">NULL</span>)&#123;</span><br><span class="line">           delete[] table; </span><br><span class="line">           table = <span class="literal">NULL</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       outFile&lt;&lt;entryNum[i]&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;entry_run1/AVERAGE_NUM&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;entry_run2/AVERAGE_NUM&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   outFile.close();</span><br></pre></td></tr></table></figure>
<p><strong>实验结果</strong></p>
<p>实验结果分为两部分：</p>
<ul>
<li><p>第一部分为数据量较小的部分，数据量小于10^4：<br><img src="/2022/07/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/image1/entryNum1.jpg" alt="image1/entryNum1.jpg"></p>
</li>
<li><p>第二部分为数据量较大的一部分，数据量直到10^7：<br><img src="/2022/07/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/image1/entryNum2.jpg" alt="image1/entryNum2.jpg"></p>
</li>
</ul>
<p><strong>结果分析</strong></p>
<ul>
<li>当数据量较小的时候，并行的优势并不能很好地体现出来，可以看到串行的运行时间要比并行的运行时间略短。可能的原因是线程的创建和删除的影响大于并行处理数据缩短的影响。</li>
<li>当数据量较大的时候，并行的优势就很好地体现出来。随着数据量的增加，并行处理的优势变得越来越大。此时并行处理数据缩短的影响大于线程的创建和删除所带来的消耗。</li>
<li>从数据图上分析，线程数为2应该提升40%～50%左右的性能，但是事实上只提高了10%～20%，因此后续我们可以进行优化。</li>
</ul>
<h4 id="6-1-4-线程数int-threadNum"><a href="#6-1-4-线程数int-threadNum" class="headerlink" title="6.1.4 线程数int threadNum"></a>6.1.4 线程数<code>int threadNum</code></h4><p><strong>测试代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> threadNum[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;结果存放于./result/result_threadNum.csv\n&quot;</span>);</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">15</span>;++i)&#123;</span><br><span class="line">       <span class="type">float</span> thread_run1 = <span class="number">0</span>;</span><br><span class="line">       <span class="type">float</span> thread_run2 = <span class="number">0</span>;</span><br><span class="line">       Result *table = new Result[DEFAULT_ENTRY_NUM]; </span><br><span class="line">       ifstream <span class="title function_">fp</span><span class="params">(data_file)</span>; </span><br><span class="line">       <span class="built_in">string</span> line;</span><br><span class="line">       <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (getline(fp,line) &amp;&amp; k &lt;= DEFAULT_ENTRY_NUM - <span class="number">1</span>)&#123; </span><br><span class="line">           <span class="built_in">string</span> number;</span><br><span class="line">           <span class="built_in">istringstream</span> <span class="title function_">readstr</span><span class="params">(line)</span>; </span><br><span class="line">           </span><br><span class="line">           getline(readstr,number,<span class="string">&#x27;,&#x27;</span>); </span><br><span class="line">           table[k].key_ = atof(number.c_str()); </span><br><span class="line"></span><br><span class="line">           getline(readstr,number,<span class="string">&#x27;,&#x27;</span>); </span><br><span class="line">           table[k].id_ = atoi(number.c_str());    </span><br><span class="line">           k++;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       fp.close();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> w = <span class="number">0</span>; w &lt; AVERAGE_NUM; w++) &#123;</span><br><span class="line">           timeval <span class="type">start_t</span>;  </span><br><span class="line">           timeval <span class="type">end_t</span>;</span><br><span class="line"></span><br><span class="line">           BTree* trees_ = new BTree();</span><br><span class="line">           trees_-&gt;init(B_, tree_file_ser);</span><br><span class="line">           gettimeofday(&amp;<span class="type">start_t</span>,<span class="literal">NULL</span>);</span><br><span class="line">       </span><br><span class="line">           <span class="keyword">if</span> (trees_-&gt;bulkload(DEFAULT_ENTRY_NUM, table)) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">           gettimeofday(&amp;<span class="type">end_t</span>, <span class="literal">NULL</span>);</span><br><span class="line">           <span class="type">float</span> run_t1 = <span class="type">end_t</span>.tv_sec - <span class="type">start_t</span>.tv_sec + </span><br><span class="line">                           (<span class="type">end_t</span>.tv_usec - <span class="type">start_t</span>.tv_usec) / <span class="number">1000000.0f</span>;</span><br><span class="line">           <span class="comment">//printf(&quot;串行运行时间: %f  s\n&quot;, run_t1);</span></span><br><span class="line">           delete trees_;</span><br><span class="line">           <span class="comment">//-------------------------------------------------------------------------------</span></span><br><span class="line">           trees_ = new BTree();</span><br><span class="line">       </span><br><span class="line">           trees_-&gt;init(B_, tree_file_par);</span><br><span class="line">           gettimeofday(&amp;<span class="type">start_t</span>,<span class="literal">NULL</span>);</span><br><span class="line">       </span><br><span class="line">           <span class="keyword">if</span> (trees_-&gt;parallelBulkLoad(DEFAULT_ENTRY_NUM, table, threadNum[i], DEFAULT_BUFFER_SIZE)) <span class="keyword">return</span> ;</span><br><span class="line">           gettimeofday(&amp;<span class="type">end_t</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">           <span class="type">float</span> run_t2 = <span class="type">end_t</span>.tv_sec - <span class="type">start_t</span>.tv_sec + </span><br><span class="line">                           (<span class="type">end_t</span>.tv_usec - <span class="type">start_t</span>.tv_usec) / <span class="number">1000000.0f</span>;</span><br><span class="line">           <span class="comment">//printf(&quot;并行运行时间: %f  s\n&quot;, run_t1);</span></span><br><span class="line">           thread_run1 += run_t1;</span><br><span class="line">           thread_run2 += run_t2;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span>(table != <span class="literal">NULL</span>)&#123;</span><br><span class="line">           delete[] table; </span><br><span class="line">           table = <span class="literal">NULL</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       outFile&lt;&lt;threadNum[i]&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;thread_run1/AVERAGE_NUM&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;thread_run2/AVERAGE_NUM&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   outFile.close();</span><br></pre></td></tr></table></figure>
<p><strong>实验结果</strong></p>
<p>实验结果也可以分为两部分，一部分是线程数小于10，由于线程数此时影响较大，我们会逐个线程数进行测试；一部分是线程数大于10后，此时线程数影响较小，我们分隔的粒度会增大，会提高到每隔5个或者10个线程数进行比较。</p>
<p>但是总的结果我们还是只放在一张图片上：<br><img src="/2022/07/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/image1/threadNum.jpg" alt="image1/threadNum.jpg"></p>
<p><strong>结果分析</strong></p>
<ul>
<li>可以看到，当线程数小于等于4时，运行时间不断地下降，而再之后却不断回升。原因在于我们的CPU处理器的核数是4，因而在线程数小于等于4时，CPU是每个线程分配一个核去运行，这时候并行处理的优势能够随着线程数的增加显示出来。</li>
<li>当线程数大于4后，运行时间整体上是不断增加的趋势，虽然中间有些许的波动。原因在于：由于CPU处理器只有4核，而线程数大于4，CPU不得不进行一定的并发处理，会轮流切换给其他线程使用，CPU的开销反而增大。</li>
</ul>
<h4 id="6-1-5-Buffer的大小int-maxBufferBlock"><a href="#6-1-5-Buffer的大小int-maxBufferBlock" class="headerlink" title="6.1.5 Buffer的大小int maxBufferBlock"></a>6.1.5 Buffer的大小<code>int maxBufferBlock</code></h4><p><strong>测试代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> bufferSize[] = &#123;<span class="number">10</span>,<span class="number">50</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">500</span>,<span class="number">1000</span>,<span class="number">2000</span>&#125;;</span><br><span class="line">outFile.<span class="built_in">open</span>(<span class="string">&quot;./result/result_bufferSize.csv&quot;</span>, ios::out);</span><br><span class="line">   outFile&lt;&lt;<span class="string">&quot;bufferSize  sertime  partime&quot;</span>&lt;&lt;endl;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;结果存放于./result/result_bufferSize.csv\n&quot;</span>);</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>;++i)&#123;</span><br><span class="line">       <span class="type">float</span> buffer_run1 = <span class="number">0</span>;</span><br><span class="line">       <span class="type">float</span> buffer_run2 = <span class="number">0</span>;</span><br><span class="line">       Result *table = <span class="keyword">new</span> Result[DEFAULT_ENTRY_NUM]; </span><br><span class="line">       <span class="function">ifstream <span class="title">fp</span><span class="params">(data_file)</span></span>; </span><br><span class="line">       string line;</span><br><span class="line">       <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (<span class="built_in">getline</span>(fp,line) &amp;&amp; k &lt;= DEFAULT_ENTRY_NUM - <span class="number">1</span>)&#123; </span><br><span class="line">           string number;</span><br><span class="line">           <span class="function">istringstream <span class="title">readstr</span><span class="params">(line)</span></span>; </span><br><span class="line">           </span><br><span class="line">           <span class="built_in">getline</span>(readstr,number,<span class="string">&#x27;,&#x27;</span>); </span><br><span class="line">           table[k].key_ = <span class="built_in">atof</span>(number.<span class="built_in">c_str</span>()); </span><br><span class="line"></span><br><span class="line">           <span class="built_in">getline</span>(readstr,number,<span class="string">&#x27;,&#x27;</span>); </span><br><span class="line">           table[k].id_ = <span class="built_in">atoi</span>(number.<span class="built_in">c_str</span>());    </span><br><span class="line">           k++;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       fp.<span class="built_in">close</span>();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> w = <span class="number">0</span>; w &lt; AVERAGE_NUM; w++) &#123;</span><br><span class="line">           timeval <span class="type">start_t</span>;  </span><br><span class="line">           timeval <span class="type">end_t</span>;</span><br><span class="line"></span><br><span class="line">           BTree* trees_ = <span class="keyword">new</span> <span class="built_in">BTree</span>();</span><br><span class="line">           trees_-&gt;<span class="built_in">init</span>(B_, tree_file_ser);</span><br><span class="line">           <span class="built_in">gettimeofday</span>(&amp;<span class="type">start_t</span>,<span class="literal">NULL</span>);</span><br><span class="line">       </span><br><span class="line">           <span class="keyword">if</span> (trees_-&gt;<span class="built_in">bulkload</span>(DEFAULT_ENTRY_NUM, table)) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">           <span class="built_in">gettimeofday</span>(&amp;<span class="type">end_t</span>, <span class="literal">NULL</span>);</span><br><span class="line">           <span class="type">float</span> run_t1 = <span class="type">end_t</span>.tv_sec - <span class="type">start_t</span>.tv_sec + </span><br><span class="line">                               (<span class="type">end_t</span>.tv_usec - <span class="type">start_t</span>.tv_usec) / <span class="number">1000000.0f</span>;</span><br><span class="line">           <span class="comment">//printf(&quot;串行运行时间: %f  s\n&quot;, run_t1);</span></span><br><span class="line">           <span class="keyword">delete</span> trees_;</span><br><span class="line">           <span class="comment">//-------------------------------------------------------------------------------</span></span><br><span class="line">           trees_ = <span class="keyword">new</span> <span class="built_in">BTree</span>();</span><br><span class="line">       </span><br><span class="line">           trees_-&gt;<span class="built_in">init</span>(B_, tree_file_par);</span><br><span class="line">           <span class="built_in">gettimeofday</span>(&amp;<span class="type">start_t</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (trees_-&gt;<span class="built_in">parallelBulkLoad</span>(DEFAULT_ENTRY_NUM, table,DEFAULT_THREAD_NUM, bufferSize[i])) <span class="keyword">return</span> ;</span><br><span class="line">           <span class="built_in">gettimeofday</span>(&amp;<span class="type">end_t</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">           <span class="type">float</span> run_t2 = <span class="type">end_t</span>.tv_sec - <span class="type">start_t</span>.tv_sec + </span><br><span class="line">                               (<span class="type">end_t</span>.tv_usec - <span class="type">start_t</span>.tv_usec) / <span class="number">1000000.0f</span>;</span><br><span class="line">           <span class="comment">//printf(&quot;并行运行时间: %f  s\n&quot;, run_t1);</span></span><br><span class="line">           buffer_run1 += run_t1;</span><br><span class="line">           buffer_run2 += run_t2;</span><br><span class="line">       &#125;        </span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span>(table != <span class="literal">NULL</span>)&#123;</span><br><span class="line">           <span class="keyword">delete</span>[] table; </span><br><span class="line">           table = <span class="literal">NULL</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       outFile&lt;&lt;bufferSize[i]&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;buffer_run1/AVERAGE_NUM&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;buffer_run2/AVERAGE_NUM&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line">   outFile.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>
<p><strong>实验结果</strong></p>
<p>实验的运行结果如下（同样是前面粒度较小而后面粒度较大）：</p>
<p><img src="/2022/07/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/image1/bufferSize.jpg" alt="image1/bufferSize.jpg"></p>
<p><strong>结果分析</strong></p>
<ul>
<li><p>可以看到Buffer的大小对串行的运行时间没有明显的影响。</p>
</li>
<li><p>而相对于并行而言：虽然前面有所起伏，但是整体上在500块Block以前运行时间是逐渐减少的。</p>
<p><strong>原因可能在于：在一定限度内，随着缓冲区变大，IO的最小粒度增大，不同线程的磁盘IO和内存中节点的构建过程并行度提升，进而减少了总运行时间。</strong></p>
</li>
</ul>
<ul>
<li><p>当Buffer的大小大于500后，运行时间却不断增加。</p>
<p><strong>分析可知：由于缓冲区过大，导致所有的线程都是先将Block写入内存，到最后才轮流进行I/O，而不是I/O和写内存并行处理，或者说此时I/O和CPU的并行度不高，因而运行时间变长。</strong></p>
</li>
</ul>
<h3 id="6-2-性能调优和创新优化实验结果及分析"><a href="#6-2-性能调优和创新优化实验结果及分析" class="headerlink" title="6.2 性能调优和创新优化实验结果及分析"></a>6.2 性能调优和创新优化实验结果及分析</h3><h4 id="6-2-1-性能调优的原因"><a href="#6-2-1-性能调优的原因" class="headerlink" title="6.2.1 性能调优的原因"></a>6.2.1 性能调优的原因</h4><ol>
<li>在上面的对entry number，也就是数据量的大小的分析中，我们可以知道，随着数据量的增加，并行的优势不断明显，但是也只是提高了10%～20%，性能以及运行时间还有很大的提升空间。</li>
<li>在对Buffer大小的分析中，我们了解到采用的I分配内存和I/O方式是一个一个进行，为了提高性能，我们有必要进行整体（多块）地进行I/O和分配内存来提高运行效率。</li>
</ol>
<p><strong>我们依旧从3个影响因素进行分析。</strong></p>
<h4 id="6-2-2-数据量的大小"><a href="#6-2-2-数据量的大小" class="headerlink" title="6.2.2 数据量的大小"></a>6.2.2 数据量的大小</h4><p><strong>实验结果</strong></p>
<p>同样分为数据量较大和数据量较小两部分：</p>
<p><img src="/2022/07/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/image3/entryNum1.jpg" alt="image3/entryNum1.jpg"></p>
<p><img src="/2022/07/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/image3/entryNum2.jpg" alt="image3/entryNum2.jpg"></p>
<p><strong>实验分析</strong></p>
<ul>
<li>在数据量较小的时候，这次在1000～2000左右并行的运行时间就优于串行的运行时间。</li>
<li>并且随着数据量的增大，并行的优势相比串行更是有了大幅度的增加。优化后的运行时长缩短了80%到90%。</li>
<li>由此可见整体分配内存和多个Block的I/O对性能有着极为重大的影响。</li>
</ul>
<h4 id="6-2-3-线程数"><a href="#6-2-3-线程数" class="headerlink" title="6.2.3 线程数"></a>6.2.3 线程数</h4><p><strong>实验结果</strong><br><img src="/2022/07/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/image3/threadNum.jpg" alt="image3/threadNum.jpg"></p>
<p><strong>实验分析</strong></p>
<ul>
<li><p>这次我们可以看到1个线程到两个线程有了明显的提高。</p>
<p><strong>原因在于：1个线程的运行相当于是串行，也就是不断地取一个一个Block写内存然后I/O，运行效率很低，而2个线程不仅将数据项并行处理，还将内存的分配和I/O进行优化，运行时长大幅减小。</strong></p>
</li>
<li><p>而2个线程之后运行时间虽然中间有所波动，但是整体上是逐渐增加的。</p>
<p><strong>原因在于：此时的运行时间已经很短，为进程分配和销毁线程的开销相比处理数据的时长的影响更大。</strong></p>
</li>
<li><p>线程数增加后，后面也不断趋于平稳。</p>
</li>
</ul>
<h4 id="6-2-4-Buffer大小"><a href="#6-2-4-Buffer大小" class="headerlink" title="6.2.4 Buffer大小"></a>6.2.4 Buffer大小</h4><p><strong>实验结果</strong><br><img src="/2022/07/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/image3/bufferSize.jpg" alt="image3/bufferSize.jpg"></p>
<p><strong>实验分析</strong></p>
<ul>
<li><p>此时BufferSize的影响对于串行和运行都不是很大。</p>
</li>
<li><p>但是并行的情况下，随着BufferSize的增加，运行时间也是有小幅度的减小。</p>
<p><strong>原因在于：随着BufferSize的增加，内存分配和I/O的粒度也不断增加，<code>fwrite</code>的调用次数也不断减小。</strong></p>
</li>
<li><p>并且在BufferSize较小的时候运行的时长有明显下降，增大之后，运行时长降幅较小。</p>
<p><strong>原因：当BufferSize较小时，对I/O次数的影响较大，当BufferSize增大后，I/O次数的变化也没有那么明显，这可能是由于对IO进行优化后，IO速度带来的对整个程序运行时间的负面影响减少，所以差异不大。</strong></p>
</li>
</ul>
<h2 id="Ⅶ-总结"><a href="#Ⅶ-总结" class="headerlink" title="Ⅶ. 总结"></a>Ⅶ. 总结</h2><p>​        我们在串行B+树 BulkLaoding 项目的基础上，设计并实现了 BulkLoading 的多核并行设计。在创新优化方面，我们设计并实现了连续分配块和连续写入磁盘的优化，让算法的性能有了较大的提升，BulkLoading 过程提速 80% 到 90% 。</p>
<p>​        我们遵循控制变量和多次求平均的原则，对代码进行了多维度的测试，得到以下结论，并在报告第六节中进行了分析和解释。</p>
<ol>
<li>随着数据量的增加，并行处理的优势变得越来越大。</li>
<li>当线程数与CPU处理器核数相近时，运行耗时最短。</li>
<li>未经优化时，缓冲区大小为500个块时，运行耗时最短，经过优化后，缓冲区大小对运行耗时的影响并不显著。</li>
</ol>
<p>​        最后结合实验分析中两张测试结果折线图，其中数据项总数为10000000，串行代码耗时在1秒左右，优化前并行代码耗时在0.75-0.9秒之间，优化后的代码耗时在0.1-0.2秒之间，可以看到我们的优化效果显著。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><center>串行代码和优化前并行代码耗时比较</center></th>
<th><center>串行代码和优化后并行代码耗时比较</center></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/2022/07/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/image1/bufferSize.jpg" alt="image1/bufferSize.jpg"></td>
<td><img src="/2022/07/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/image3/bufferSize.jpg" alt="image3/bufferSize.jpg"></td>
</tr>
</tbody>
</table>
</div>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">HogarHuang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://huanghj78.github.io/2022/07/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/">https://huanghj78.github.io/2022/07/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post_share"><div class="social-share" data-image="/images/background.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://fastly.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/07/31/3D%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A%E9%9B%86%E5%90%88/"><img class="prev-cover" src="/images/background.jpg" onerror="onerror=null;src='/img/night.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">课程作业集合</div></div></a></div><div class="next-post pull-right"><a href="/2022/07/30/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/ST-Assignment8/"><img class="next-cover" src="/images/background.jpg" onerror="onerror=null;src='/img/night.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">软件测试-Assignment8 判定表法</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">数据库系统课程设计报告</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.1.</span> <span class="toc-text">B+树 BulkLoading 多核并行设计（小组作业）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A0-B-%E6%A0%91-BulkLoading-%E8%BF%87%E7%A8%8B%E7%90%86%E8%A7%A3"><span class="toc-number">1.2.</span> <span class="toc-text">Ⅰ. B+树 BulkLoading 过程理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-BulkLoading-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.1 BulkLoading 的基本思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E7%BB%93%E5%90%88%E5%AE%9E%E7%8E%B0%E7%90%86%E8%A7%A3-BulkLoading"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2 结合实现理解 BulkLoading</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-BulkLoading-%E7%9A%84%E5%88%A9%E5%BC%8A"><span class="toc-number">1.2.3.</span> <span class="toc-text">1.3 BulkLoading 的利弊</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A1-%E5%B9%B6%E8%A1%8C%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="toc-number">1.3.</span> <span class="toc-text">Ⅱ. 并行设计思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%9F%BA%E6%9C%AC%E6%83%B3%E6%B3%95"><span class="toc-number">1.3.1.</span> <span class="toc-text">2.1 基本想法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%B9%B6%E8%A1%8C%E6%80%9D%E8%B7%AF%E5%9B%BE%E8%A7%A3"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.2 并行思路图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%9B%B4%E5%A4%9A%E8%AE%A8%E8%AE%BA"><span class="toc-number">1.3.3.</span> <span class="toc-text">2.3 更多讨论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A2-%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">1.4.</span> <span class="toc-text">Ⅲ. 算法流程图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A3-%E5%88%9B%E6%96%B0%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF"><span class="toc-number">1.5.</span> <span class="toc-text">Ⅳ. 创新优化思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E5%9D%97"><span class="toc-number">1.5.1.</span> <span class="toc-text">4.1 连续分配块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E8%BF%9E%E7%BB%AD%E5%86%99%E7%A3%81%E7%9B%98"><span class="toc-number">1.5.2.</span> <span class="toc-text">4.2 连续写磁盘</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A4-%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.6.</span> <span class="toc-text">Ⅴ. 关键代码描述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-parallelBulkLoad"><span class="toc-number">1.6.1.</span> <span class="toc-text">5.1 parallelBulkLoad</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-batchLoadLeaf-%E5%92%8C-batchLoadIndex"><span class="toc-number">1.6.2.</span> <span class="toc-text">5.2 batchLoadLeaf 和 batchLoadIndex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-append-blocks%E3%80%81init-noalloc-%E5%92%8C-alloc-blocks"><span class="toc-number">1.6.3.</span> <span class="toc-text">5.3 append_blocks、init_noalloc 和  alloc_blocks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-write-blocks%E3%80%81write-leaf-blocks-%E5%92%8C-write-index-blocks"><span class="toc-number">1.6.4.</span> <span class="toc-text">5.4 write_blocks、write_leaf_blocks 和 write_index_blocks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-write-B-tree"><span class="toc-number">1.6.5.</span> <span class="toc-text">5.5 write_B_tree</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A5-%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90"><span class="toc-number">1.7.</span> <span class="toc-text">Ⅵ. 实验结果分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-0-%E5%B9%B6%E8%A1%8C%E5%92%8C%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E7%9A%84%E4%BB%A3%E7%A0%81%E8%AF%B4%E6%98%8E"><span class="toc-number">1.7.1.</span> <span class="toc-text">6.0 并行和性能调优的代码说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-0-1-%E6%94%B9%E4%B8%BA%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%99%E7%A3%81%E7%9B%98%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">6.0.1 改为非连续写磁盘的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-0-2-%E6%94%B9%E4%B8%BA%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E5%9D%97%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">6.0.2 改为非连续分配块的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-0-3-%E5%A6%82%E4%BD%95%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">6.0.3 如何测试代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%B9%B6%E8%A1%8C%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C%E4%BB%A3%E7%A0%81%E5%8F%8A%E5%88%86%E6%9E%90"><span class="toc-number">1.7.2.</span> <span class="toc-text">6.1 并行实验结果代码及分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-%E5%BD%B1%E5%93%8D%E5%9B%A0%E7%B4%A0"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">6.1.1 影响因素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-%E5%AE%9E%E9%AA%8C%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">6.1.2 实验方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-3-%E6%95%B0%E6%8D%AE%E9%A1%B9%E7%9A%84%E6%95%B0%E7%9B%AEint-n"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">6.1.3 数据项的数目int n</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-4-%E7%BA%BF%E7%A8%8B%E6%95%B0int-threadNum"><span class="toc-number">1.7.2.4.</span> <span class="toc-text">6.1.4 线程数int threadNum</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-5-Buffer%E7%9A%84%E5%A4%A7%E5%B0%8Fint-maxBufferBlock"><span class="toc-number">1.7.2.5.</span> <span class="toc-text">6.1.5 Buffer的大小int maxBufferBlock</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%92%8C%E5%88%9B%E6%96%B0%E4%BC%98%E5%8C%96%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C%E5%8F%8A%E5%88%86%E6%9E%90"><span class="toc-number">1.7.3.</span> <span class="toc-text">6.2 性能调优和创新优化实验结果及分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">6.2.1 性能调优的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-%E6%95%B0%E6%8D%AE%E9%87%8F%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">6.2.2 数据量的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-3-%E7%BA%BF%E7%A8%8B%E6%95%B0"><span class="toc-number">1.7.3.3.</span> <span class="toc-text">6.2.3 线程数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-4-Buffer%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.7.3.4.</span> <span class="toc-text">6.2.4 Buffer大小</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A6-%E6%80%BB%E7%BB%93"><span class="toc-number">1.8.</span> <span class="toc-text">Ⅶ. 总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/luka.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">HogarHuang</div><div class="author-info__description">1353188493@qq.com</div></div></div></div></div></main><footer id="footer" style="background: #FFFFFF"><div id="footer-wrap"><div class="copyright">&copy;2022 By HogarHuang</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/chenxz21/hexo-theme-bcxm">Bcxm</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/leancloud-storage@4.10.0/dist/av-min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>