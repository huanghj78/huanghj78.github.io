<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>OS-浅析System V和POSIX下的IPC</title><meta name="author" content="HogarHuang"><meta name="copyright" content="HogarHuang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="浅析System V和POSIX下的IPC1. 引言与概述​        首先，从标题我们不难看出共有三个关键字——System V、POSIX和IPC。 ​        我们知道IPC即Inter Pocess Communication，进程间通信，它的实现主要有System V和POSIX两种类型。 ​        System V我们从维基百科可以了解到，它是Unix操作系统中的一个">
<meta property="og:type" content="article">
<meta property="og:title" content="OS-浅析System V和POSIX下的IPC">
<meta property="og:url" content="https://huanghj78.github.io/2022/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%85%E6%9E%90System%20V%E5%92%8CPOSIX%E4%B8%8B%E7%9A%84IPC/index.html">
<meta property="og:site_name" content="Hogar&#39;s Blog">
<meta property="og:description" content="浅析System V和POSIX下的IPC1. 引言与概述​        首先，从标题我们不难看出共有三个关键字——System V、POSIX和IPC。 ​        我们知道IPC即Inter Pocess Communication，进程间通信，它的实现主要有System V和POSIX两种类型。 ​        System V我们从维基百科可以了解到，它是Unix操作系统中的一个">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://huanghj78.github.io/images/background.jpg">
<meta property="article:published_time" content="2022-08-06T15:26:24.493Z">
<meta property="article:modified_time" content="2022-08-06T15:27:53.953Z">
<meta property="article:author" content="HogarHuang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huanghj78.github.io/images/background.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huanghj78.github.io/2022/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%85%E6%9E%90System%20V%E5%92%8CPOSIX%E4%B8%8B%E7%9A%84IPC/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: HogarHuang","link":"Link: ","source":"Source: Hogar's Blog","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'OS-浅析System V和POSIX下的IPC',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-08-06 23:27:53'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="is-center"><div class="avatar-img"><img src="/img/luka.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">HogarHuang</div><div class="author-info__description">1353188493@qq.com</div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-clock"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/records"><i class="fa-fw fas fa-comment-dots"></i><span> 随记</span></a></div><div class="menus_item"><a class="site-page" href="/gedan"><i class="fa-fw fas fa-music"></i><span> 歌单</span></a></div><div class="menus_item"><a class="site-page" href="/game"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk"><i class="fa-fw fa fa-heartbeat"></i><span> 时光</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-tools"></i><span> 工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/google"><span> 镜像</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://json.xbyzs.cf"><span> Json格式化</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://draw.xbyzs.cf"><span> Draw画布</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://enkey.xbyzs.cf"><span> EnKey</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hogar's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-clock"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/records"><i class="fa-fw fas fa-comment-dots"></i><span> 随记</span></a></div><div class="menus_item"><a class="site-page" href="/gedan"><i class="fa-fw fas fa-music"></i><span> 歌单</span></a></div><div class="menus_item"><a class="site-page" href="/game"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk"><i class="fa-fw fa fa-heartbeat"></i><span> 时光</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-tools"></i><span> 工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/google"><span> 镜像</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://json.xbyzs.cf"><span> Json格式化</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://draw.xbyzs.cf"><span> Draw画布</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://enkey.xbyzs.cf"><span> EnKey</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">OS-浅析System V和POSIX下的IPC</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">Created</span><time datetime="2022-08-06T15:26:24.493Z" title="Created 2022-08-06 23:26:24">2022-08-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"></div></div></div><article class="post-content" id="article-container"><h1 id="浅析System-V和POSIX下的IPC"><a href="#浅析System-V和POSIX下的IPC" class="headerlink" title="浅析System V和POSIX下的IPC"></a>浅析System V和POSIX下的IPC</h1><h2 id="1-引言与概述"><a href="#1-引言与概述" class="headerlink" title="1. 引言与概述"></a>1. 引言与概述</h2><p>​        首先，从标题我们不难看出共有三个关键字——System V、POSIX和IPC。</p>
<p>​        我们知道IPC即Inter Pocess Communication，进程间通信，它的实现主要有System V和POSIX两种类型。</p>
<p>​        System V我们从维基百科可以了解到，它是Unix操作系统中的一个版本，Unix操作系统有许多版本，因此为了减少各种实现之间的差异，IEEE就制定出了POSIX标准，即Portable Operating System Interface，可移植操作系统接口，其中的X表示其对UnixAPI的传承。该标准是基于现有的UNIX 实践和经验，描述了操作系统的调用服务接口，用于保证编制的应用程序可以在源代码一级上在多种操作系统上移植运行。</p>
<p><img src="/2022/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%85%E6%9E%90System%20V%E5%92%8CPOSIX%E4%B8%8B%E7%9A%84IPC/浅谈SystemV和Posix下IPC的区别.assets\image-20220312152020696.png" alt="image-20220312152020696"></p>
<p>​        所以本次讨论我们主要围绕System V和POSIX的IPC实现，我们知道，进程是操作系统进行资源分配最基本的单位，一个程序无论是简简单单的Hello World，亦或一个庞大复杂的工程项目，归根到底是由一个个进程不知疲倦地进行01的计算而实现的。当然，如果他们之间各干各的，那就是几条平行的直线，永不相交，单调乏味。只有他们之间能够进行通信、协作，才能产生更加复杂且有用的功能，由此,IPC的重要性可见一斑。</p>
<h2 id="2-共享内存-Shared-Memory"><a href="#2-共享内存-Shared-Memory" class="headerlink" title="2. 共享内存 Shared Memory"></a>2. 共享内存 Shared Memory</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>​        共享内存是进程间通信最快的一种方式。它的基本思想可以由下面这张图所描述</p>
<p><img src="/2022/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%85%E6%9E%90System%20V%E5%92%8CPOSIX%E4%B8%8B%E7%9A%84IPC/浅谈SystemV和Posix下IPC的区别.assets\选区_004.png" alt="选区_004"></p>
<p>​        我们知道，每个进程都有自己的一个虚拟地址空间，共享内存所做的就是将一块内存的实际物理地址分别映射到多个进程的地址空间上，使得多个进程都可以同时访问到那块内存空间，这样一来，他们之间的通信就可以借助这块内存，进行信息的交换。所以它的基本思想就是内存的映射，通过映射使得进程间可以访问一块公共区域，来使得它们之间产生联系。</p>
<p>​        在申请一块共享内存的时候，是需要绑定一个文件的（实际上后面的消息传递、管道都需要文件，Linux下万物皆为文件），文件一般是存储在磁盘中，这与共享内存有什么关系呢？实际上共享内存是基于特殊的文件系统tmpfs，即临时文件系统，它是一种基于内存的文件系统，可以使用RAM或swap分区来进行存储，它是由内核管理。</p>
<blockquote>
<p>Tmpfs is a file system which keeps all of its files in virtual memory.</p>
<p>Everything in tmpfs is temporary in the sense that no files will be</p>
<p>created on your hard drive. If you unmount a tmpfs instance,</p>
<p>everything stored therein is lost.</p>
<p>tmpfs puts everything into the kernel internal caches and grows and</p>
<p>shrinks to accommodate the files it contains and is able to swap</p>
<p>unneeded pages out to swap space. It has maximum size limits which can</p>
<p>be adjusted on the fly via ‘mount -o remount …’</p>
</blockquote>
<h3 id="2-2-System-V"><a href="#2-2-System-V" class="headerlink" title="2.2 System V"></a>2.2 System V</h3><p>引用：<sys shm.h></sys></p>
<h4 id="2-2-1-生成键值-ftok"><a href="#2-2-1-生成键值-ftok" class="headerlink" title="2.2.1 生成键值 ftok"></a>2.2.1 生成键值 ftok</h4><p>​        由于IPC都需要有中间介质来实现，因此首先需要由该函数得到一个IPC key，后续的操作就需要用到该key。它的作用是通过传入的一个带路径的文件名（可用绝对路径或相对路径）和自定义的一个ID，生成一个键值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Generates key for System V style IPC.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">key_t</span> <span class="title function_">ftok</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *__pathname, <span class="type">int</span> __proj_id)</span> __THROW;</span><br></pre></td></tr></table></figure>
<ul>
<li>功能：生成文件对应的键值，以供后续使用</li>
<li>参数1<code>__pathname</code>为一个带路径的文件名（可用绝对路径或相对路径）</li>
<li>参数2<code>__proj_id</code>为一个自定义ID</li>
<li>返回值为一个键值，用于后续创建共享内存并对共享内存进行操作，其中key_t为int类型</li>
<li>key值生成的原理是利用传入id的低8位+传入文件的设备编号的低8位+文件节点编号的低16位，验证如下</li>
</ul>
<p>stat是一个文件的信息结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span>  </span></span><br><span class="line"><span class="class">&#123;</span>   </span><br><span class="line">    <span class="type">dev_t</span>       st_dev;     <span class="comment">/* ID of device containing file -文件所在设备的ID*/</span>  </span><br><span class="line">    <span class="type">ino_t</span>       st_ino;     <span class="comment">/* inode number -inode节点号*/</span>    </span><br><span class="line">    <span class="type">mode_t</span>      st_mode;    <span class="comment">/* 文件模式*/</span>    </span><br><span class="line">    <span class="type">nlink_t</span>     st_nlink;   <span class="comment">/* number of hard links -链向此文件的连接数(硬连接)*/</span>    </span><br><span class="line">    <span class="type">uid_t</span>       st_uid;     <span class="comment">/* user ID of owner -user id*/</span>    </span><br><span class="line">    <span class="type">gid_t</span>       st_gid;     <span class="comment">/* group ID of owner - group id*/</span>    </span><br><span class="line">    <span class="type">dev_t</span>       st_rdev;    <span class="comment">/* device ID (if special file) -设备号，针对设备文件*/</span>    </span><br><span class="line">    <span class="type">off_t</span>       st_size;    <span class="comment">/* total size, in bytes -文件大小，字节为单位*/</span>    </span><br><span class="line">    <span class="type">blksize_t</span>   st_blksize; <span class="comment">/* blocksize for filesystem I/O -系统块的大小*/</span>    </span><br><span class="line">    <span class="type">blkcnt_t</span>    st_blocks;  <span class="comment">/* number of blocks allocated -文件所占块数*/</span>    </span><br><span class="line">    <span class="type">time_t</span>      st_atime;   <span class="comment">/* time of last access -最近存取时间*/</span>    </span><br><span class="line">    <span class="type">time_t</span>      st_mtime;   <span class="comment">/* time of last modification -最近修改时间*/</span>    </span><br><span class="line">    <span class="type">time_t</span>      st_ctime;   <span class="comment">/* time of last status change - */</span>    </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> fileName[<span class="number">100</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">buf</span>;</span></span><br><span class="line">    <span class="built_in">strcpy</span>(fileName, <span class="string">&quot;/home/huanghj/myshm&quot;</span>);</span><br><span class="line">    <span class="type">int</span> ret = stat(fileName, &amp;buf);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat()&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;st_dev = 0x%x\n&quot;</span>,buf.st_dev);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;st_ino = 0x%x\n&quot;</span>,buf.st_ino);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;/home/huanghj/myshm&quot;</span>, <span class="number">0x66</span>);</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;ftok()&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;key = 0x%x\n&quot;</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的结果如下：</p>
<p><img src="/2022/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%85%E6%9E%90System%20V%E5%92%8CPOSIX%E4%B8%8B%E7%9A%84IPC/选区_011.png" alt="选区_002"></p>
<p>由此我们可以得到一些需要注意的地方</p>
<ul>
<li>传入的文件名对应的文件必须是存在的，因为需要用到该文件的信息，若不存在则返回的key为-1</li>
<li>传入的id实际上只取低8位</li>
<li>由于ftok生成键值的原理，可能会导致一个问题：在访问同一共享内存的多个进程先后调用ftok()时间段中，如果__pathname指向的文件或者目录被删除而且又重新创建，那么文件系统会赋予这个同名文件新的i节点信息，于是这些进程调用的ftok()都能正常返回，但键值key却不一定相同了。由此可能造成的后果是，原本这些进程意图访问一个相同的共享内存对象，然而由于它们各自得到的键值不同，实际上进程指向的共享内存不再一致；如果这些共享内存都得到创建，则在整个应用运行的过程中表面上不会报出任何错误，然而通过一个共享内存对象进行数据传输的目的将无法实现。</li>
</ul>
<h4 id="2-2-2-创建共享内存-shmget"><a href="#2-2-2-创建共享内存-shmget" class="headerlink" title="2.2.2 创建共享内存 shmget"></a>2.2.2 创建共享内存 shmget</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get shared memory segment.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">shmget</span> <span class="params">(<span class="type">key_t</span> __key, <span class="type">size_t</span> __size, <span class="type">int</span> __shmflg)</span> __THROW;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数1<code>__key</code>一般为前面通过ftok()所得到的键值，也可以传<code>IPC_PRIVATE</code>，实际上它就是宏定义为0。</p>
<p><code>IPC_PRIVATE</code>从这个名字似乎就与共享内存的share有点矛盾，确实，如果我们传的是<code>IPC_PRIVATE</code>，那么得到的这块内存是无法和跟这个进程<strong>无关</strong>的其他进程所共享的。从shmget()的实现可以看到，一但传的是<code>IPC_PRIVATE</code>，那么它就会直接创建一块新的共享内存，因此每个进程若都传的是<code>IPC_PRIVATE</code>那么它们都会各自得到一块自己所独有的共享内存，那么这块内存还能怎么共享了？实际上这就类似于匿名管道，由持有该共享内存的进程所fork出的子进程便可访问到该共享内存。</p>
<p>我们可以简单地看一下源码（5.16.14）</p>
<p>首先是一个比较重要的结构体<code>shmid_ds</code>，它是描述了一块共享内存的基本信息，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: /usr/include/x86_64-linux-gnu/bits/shm.h</span></span><br><span class="line"><span class="comment">/* Data structure describing a shared memory segment.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span>		<span class="title">shm_perm</span>;</span>	<span class="comment">/* operation perms */</span></span><br><span class="line">	<span class="type">int</span>			shm_segsz;	<span class="comment">/* size of segment (bytes) */</span></span><br><span class="line">	<span class="type">__kernel_time_t</span>		shm_atime;	<span class="comment">/* last attach time */</span></span><br><span class="line">	<span class="type">__kernel_time_t</span>		shm_dtime;	<span class="comment">/* last detach time */</span></span><br><span class="line">	<span class="type">__kernel_time_t</span>		shm_ctime;	<span class="comment">/* last change time */</span></span><br><span class="line">	<span class="type">__kernel_ipc_pid_t</span>	shm_cpid;	<span class="comment">/* pid of creator */</span></span><br><span class="line">	<span class="type">__kernel_ipc_pid_t</span>	shm_lpid;	<span class="comment">/* pid of last operator */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>		shm_nattch;	<span class="comment">/* no. of current attaches */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> 		shm_unused;	<span class="comment">/* compatibility */</span></span><br><span class="line">	<span class="type">void</span> 			*shm_unused2;	<span class="comment">/* ditto - used by DIPC */</span></span><br><span class="line">	<span class="type">void</span>			*shm_unused3;	<span class="comment">/* unused */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">__kernel_key_t</span>	key; <span class="comment">// IPC对象键值，即创建共享内存时用户指定的</span></span><br><span class="line">	<span class="type">__kernel_uid_t</span>	uid;  <span class="comment">// IPC对象拥有者id</span></span><br><span class="line">	<span class="type">__kernel_gid_t</span>	gid;  <span class="comment">//组id</span></span><br><span class="line">	<span class="type">__kernel_uid_t</span>	cuid; <span class="comment">// 创建者id</span></span><br><span class="line">	<span class="type">__kernel_gid_t</span>	cgid;</span><br><span class="line">	<span class="type">__kernel_mode_t</span>	mode; </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>	seq;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>shmget函数它的实现如下：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(shmget, <span class="type">key_t</span>, key, <span class="type">size_t</span>, size, <span class="type">int</span>, shmflg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> ksys_shmget(key, size, shmflg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ipc_namespace可以简单地对比C++里面的命名空间进行理解，只有处于同一个ipc_namespace中的进程才能通过IPC对象进行通信。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">ksys_shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipc_ops</span> <span class="title">shm_ops</span> =</span> &#123;</span><br><span class="line">		.getnew = newseg,</span><br><span class="line">		.associate = security_shm_associate,</span><br><span class="line">		.more_checks = shm_more_checks,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_params</span> <span class="title">shm_params</span>;</span></span><br><span class="line"></span><br><span class="line">	ns = current-&gt;nsproxy-&gt;ipc_ns;</span><br><span class="line"></span><br><span class="line">	shm_params.key = key;</span><br><span class="line">	shm_params.flg = shmflg;</span><br><span class="line">	shm_params.u.size = size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ipcget(ns, &amp;shm_ids(ns), &amp;shm_ops, &amp;shm_params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Structure that holds some ipc operations. This structure is used to unify</span></span><br><span class="line"><span class="comment"> * the calls to sys_msgget(), sys_semget(), sys_shmget()</span></span><br><span class="line"><span class="comment"> *      . routine to call to create a new ipc object. Can be one of newque,</span></span><br><span class="line"><span class="comment"> *        newary, newseg</span></span><br><span class="line"><span class="comment"> *      . routine to call to check permissions for a new ipc object.</span></span><br><span class="line"><span class="comment"> *        Can be one of security_msg_associate, security_sem_associate,</span></span><br><span class="line"><span class="comment"> *        security_shm_associate</span></span><br><span class="line"><span class="comment"> *      . routine to call for an extra check if needed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_ops</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> (*getnew)(<span class="keyword">struct</span> ipc_namespace *, <span class="keyword">struct</span> ipc_params *);</span><br><span class="line">	<span class="type">int</span> (*associate)(<span class="keyword">struct</span> kern_ipc_perm *, <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*more_checks)(<span class="keyword">struct</span> kern_ipc_perm *, <span class="keyword">struct</span> ipc_params *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ipcget - Common sys_*get() code</span></span><br><span class="line"><span class="comment"> * @ns: namespace</span></span><br><span class="line"><span class="comment"> * @ids: ipc identifier set</span></span><br><span class="line"><span class="comment"> * @ops: operations to be called on ipc object creation, permission checks</span></span><br><span class="line"><span class="comment"> *       and further checks</span></span><br><span class="line"><span class="comment"> * @params: the parameters needed by the previous operations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Common routine called by sys_msgget(), sys_semget() and sys_shmget().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ipcget</span><span class="params">(<span class="keyword">struct</span> ipc_namespace *ns, <span class="keyword">struct</span> ipc_ids *ids,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="keyword">struct</span> ipc_ops *ops, <span class="keyword">struct</span> ipc_params *params)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (params-&gt;key == IPC_PRIVATE)</span><br><span class="line">		<span class="keyword">return</span> ipcget_new(ns, ids, ops, params);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> ipcget_public(ns, ids, ops, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当传入IPC_PRIVATE时，可以看到会直接创建一个ipc对象，也就是申请一块新的共享内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ipcget_new -	create a new ipc object</span></span><br><span class="line"><span class="comment"> * @ns: ipc namespace</span></span><br><span class="line"><span class="comment"> * @ids: ipc identifier set</span></span><br><span class="line"><span class="comment"> * @ops: the actual creation routine to call</span></span><br><span class="line"><span class="comment"> * @params: its parameters</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This routine is called by sys_msgget, sys_semget() and sys_shmget()</span></span><br><span class="line"><span class="comment"> * when the key is IPC_PRIVATE.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ipcget_new</span><span class="params">(<span class="keyword">struct</span> ipc_namespace *ns, <span class="keyword">struct</span> ipc_ids *ids,</span></span><br><span class="line"><span class="params">		<span class="type">const</span> <span class="keyword">struct</span> ipc_ops *ops, <span class="keyword">struct</span> ipc_params *params)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	down_write(&amp;ids-&gt;rwsem);</span><br><span class="line">	err = ops-&gt;getnew(ns, params);</span><br><span class="line">	up_write(&amp;ids-&gt;rwsem);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当传的不是<code>IPC_PRIVATE</code>时，则会执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ipcget_public - get an ipc object or create a new one</span></span><br><span class="line"><span class="comment"> * @ns: ipc namespace</span></span><br><span class="line"><span class="comment"> * @ids: ipc identifier set</span></span><br><span class="line"><span class="comment"> * @ops: the actual creation routine to call</span></span><br><span class="line"><span class="comment"> * @params: its parameters</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This routine is called by sys_msgget, sys_semget() and sys_shmget()</span></span><br><span class="line"><span class="comment"> * when the key is not IPC_PRIVATE.</span></span><br><span class="line"><span class="comment"> * It adds a new entry if the key is not found and does some permission</span></span><br><span class="line"><span class="comment"> * / security checkings if the key is found.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On success, the ipc id is returned.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ipcget_public</span><span class="params">(<span class="keyword">struct</span> ipc_namespace *ns, <span class="keyword">struct</span> ipc_ids *ids,</span></span><br><span class="line"><span class="params">		<span class="type">const</span> <span class="keyword">struct</span> ipc_ops *ops, <span class="keyword">struct</span> ipc_params *params)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> *<span class="title">ipcp</span>;</span></span><br><span class="line">	<span class="type">int</span> flg = params-&gt;flg;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Take the lock as a writer since we are potentially going to add</span></span><br><span class="line"><span class="comment">	 * a new entry + read locks are not &quot;upgradable&quot;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	down_write(&amp;ids-&gt;rwsem);<span class="comment">//写者获取读信号量</span></span><br><span class="line">	ipcp = ipc_findkey(ids, params-&gt;key);</span><br><span class="line">	<span class="keyword">if</span> (ipcp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">/* key not used */</span></span><br><span class="line">		<span class="keyword">if</span> (!(flg &amp; IPC_CREAT))</span><br><span class="line">			err = -ENOENT;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			err = ops-&gt;getnew(ns, params);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* ipc object has been locked by ipc_findkey() */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (flg &amp; IPC_CREAT &amp;&amp; flg &amp; IPC_EXCL)</span><br><span class="line">			err = -EEXIST;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			err = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (ops-&gt;more_checks)</span><br><span class="line">				err = ops-&gt;more_checks(ipcp, params);</span><br><span class="line">			<span class="keyword">if</span> (!err)</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * ipc_check_perms returns the IPC id on</span></span><br><span class="line"><span class="comment">				 * success</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				err = ipc_check_perms(ns, ipcp, ops, params);</span><br><span class="line">		&#125;</span><br><span class="line">		ipc_unlock(ipcp);</span><br><span class="line">	&#125;</span><br><span class="line">	up_write(&amp;ids-&gt;rwsem);<span class="comment">//写者释放读写信号量</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数2<code>__size</code>为共享内存的大小，单位为字节</p>
<p>​    <img src="/2022/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%85%E6%9E%90System%20V%E5%92%8CPOSIX%E4%B8%8B%E7%9A%84IPC/选区_003.png" alt="选区_003"></p>
</li>
<li><p>参数3<code>__shmflg</code>为标志位以及共享内存的读写权限</p>
<p>标志位主要有：</p>
<p>​    <code>IPC_CREATE</code>如果共享内存不存在，则创建一个共享内存，否则打开操作。</p>
<p>​    <code>IPC_EXCL</code> 只有在共享内存不存在的时候，新的共享内存才建立，否则就产生错误。</p>
</li>
<li><p>返回值为所创建的共享内存的ID，失败时返回-1</p>
</li>
<li><p>总的来说，shmget()执行作用就是分配出一块共享内存，并返回该内存的shmid，后续进程可以通过该shmid将该内存的地址映射到自己的地址空间上从而可以进行访问。</p>
</li>
</ul>
<h4 id="2-2-3-映射共享内存-shmat"><a href="#2-2-3-映射共享内存-shmat" class="headerlink" title="2.2.3 映射共享内存 shmat"></a>2.2.3 映射共享内存 shmat</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Attach shared memory segment.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> *<span class="title function_">shmat</span> <span class="params">(<span class="type">int</span> __shmid, <span class="type">const</span> <span class="type">void</span> *__shmaddr, <span class="type">int</span> __shmflg)</span></span><br><span class="line">     __THROW;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数1<code>__shmid</code>为要映射的共享内存的ID</p>
</li>
<li><p>参数2<code>__shmaddr</code>为指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址。</p>
</li>
<li><p>参数3<code>__shmflg</code>为一组标志位，通常也是选择0。</p>
<ul>
<li><strong>SHM_RDONLY</strong>表示只读模式</li>
<li><strong>SHM_REMAP</strong> ：如果指定了SHM_REMAP标志，并且传递的addr不为NULL，则在连接段之前，会清除虚拟地址范围中的所有现有映射。如果未指定标志，addr不为NULL，并且虚拟地址范围包含一些预先存在的映射，则shmat（）调用将失败。</li>
<li><strong>SHM_RND</strong>，它会搭配参数2不为0的情况，它会地址向下取最近一个SHMLBA的倍数，SHMLBA实际上就是页的大小</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Segment low boundary address multiple.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHMLBA		(__getpagesize ())</span></span><br></pre></td></tr></table></figure>
<p>下面是shmat实现过程中对于地址参数的处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ipc/shm.c/long do_shmat(int shmid, char __user *shmaddr, int shmflg,ulong *raddr, unsigned long shmlba)</span></span><br><span class="line"><span class="keyword">if</span> (addr) &#123;</span><br><span class="line">		<span class="keyword">if</span> (addr &amp; (shmlba - <span class="number">1</span>)) &#123; <span class="comment">// 检查是否对齐</span></span><br><span class="line">			<span class="keyword">if</span> (shmflg &amp; SHM_RND) &#123;</span><br><span class="line">				addr &amp;= ~(shmlba - <span class="number">1</span>);  <span class="comment">/* round down */</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * Ensure that the round-down is non-nil</span></span><br><span class="line"><span class="comment">				 * when remapping. This can happen for</span></span><br><span class="line"><span class="comment">				 * cases when addr &lt; shmlba.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="keyword">if</span> (!addr &amp;&amp; (shmflg &amp; SHM_REMAP))</span><br><span class="line">					<span class="keyword">goto</span> out;</span><br><span class="line">			&#125; <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ARCH_FORCE_SHMLBA</span></span><br><span class="line">				<span class="keyword">if</span> (addr &amp; ~PAGE_MASK)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">					<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		flags |= MAP_FIXED;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((shmflg &amp; SHM_REMAP))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回值为该段所连接的实际地址</p>
</li>
<li><p>第一次创建完共享内存时，它还不能被任何进程访问，shmat()函数的作用就是用来启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间。</p>
</li>
<li><p>在经过一系列参数的处理之后，真正去实现内存映射的是去调用了do_mmap完成了地址的映射</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addr = do_mmap(file, addr, size, prot, flags, <span class="number">0</span>, &amp;populate, <span class="literal">NULL</span>);</span><br><span class="line">*raddr = addr;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-2-4-解除内存映射-shmdt"><a href="#2-2-4-解除内存映射-shmdt" class="headerlink" title="2.2.4 解除内存映射 shmdt"></a>2.2.4 解除内存映射 shmdt</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Detach shared memory segment.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">shmdt</span> <span class="params">(<span class="type">const</span> <span class="type">void</span> *__shmaddr)</span> __THROW;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数<code>__shmaddr</code>指向共享内存的指针</li>
<li>返回值：成功返回0，否则返回-1</li>
</ul>
<h4 id="2-2-5-共享内存控制-shmctl"><a href="#2-2-5-共享内存控制-shmctl" class="headerlink" title="2.2.5 共享内存控制 shmctl"></a>2.2.5 共享内存控制 shmctl</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Shared memory control operation.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">shmctl</span> <span class="params">(<span class="type">int</span> __shmid, <span class="type">int</span> __cmd, <span class="keyword">struct</span> shmid_ds *__buf)</span> __THROW;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>功能：通过传入命令参数对共享内存进行相应的管理</p>
</li>
<li><p>参数1<code>__shmid</code>要操作的共享内存的ID</p>
</li>
<li><p>参数2<code>__cmd</code>操作的命令</p>
<ul>
<li>IPC_STAT：得到共享内存的状态，把共享内存的shmid_ds结构复制到buf中</li>
<li>IPC_SET：改变共享内存的状态，把buf所指的shmid_ds结构中的uid、gid、mode复制到共享内存的shmid_ds结构内。需要注意的是，调用该函数的进程的uid必须与shm_perm中的uid或者cuid一致，除非它有超级用户的权利，也就是说只有本身能够操控这块共享内存的权限时，才能去进行修改。</li>
<li>IPC_RMID：删除指定的共享内存，前提时当前已经没有其他进程映射在这块共享内存。它的使用条件跟IPC_SET一样，只有本身能够操控这块共享内存的权限时，才能进行删除。</li>
</ul>
</li>
</ul>
<h3 id="2-3-POSIX"><a href="#2-3-POSIX" class="headerlink" title="2.3 POSIX"></a>2.3 POSIX</h3><p>引用<sys mman.h></sys></p>
<h4 id="2-3-1-创建-打开共享内存-shm-open"><a href="#2-3-1-创建-打开共享内存-shm-open" class="headerlink" title="2.3.1 创建/打开共享内存 shm_open"></a>2.3.1 创建/打开共享内存 shm_open</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Open shared memory segment.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">shm_open</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *__name, <span class="type">int</span> __oflag, <span class="type">mode_t</span> __mode)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>功能：打开一块共享内存</li>
<li>参数1<code>__name</code>：共享内存对象的名字，与shm_get()不同，共享内存的文件默认是存放在/dev/shm/下，因此只需要指定一个文件名即可</li>
<li>参数2<code>__oflag</code>：操作标志<ul>
<li>O_RDONLY：仅可读</li>
<li>O_RDWR：可读可写</li>
<li>O_CREAT：指定共享内存不存在时进行创建</li>
<li>O_EXCL：检查文件是否存在，不存在则新建，存在则返回错误信息</li>
<li>O_TRUNC：清空写</li>
</ul>
</li>
<li>参数3<code>__mode</code>：共享内存对象的访问权限</li>
<li>返回值：成功时返回共享内存对象的文件描述符，失败返回-1</li>
</ul>
<h4 id="2-3-2-设置共享内存大小-ftruncate"><a href="#2-3-2-设置共享内存大小-ftruncate" class="headerlink" title="2.3.2 设置共享内存大小 ftruncate"></a>2.3.2 设置共享内存大小 ftruncate</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Truncate the file FD is open on to LENGTH bytes.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">ftruncate</span> <span class="params">(<span class="type">int</span> __fd, <span class="type">__off_t</span> __length)</span> __THROW __wur;</span><br></pre></td></tr></table></figure>
<ul>
<li>功能：设置共享内内存的大小</li>
<li>参数1<code>__fd</code>：shm_open()得到的文件句柄</li>
<li>参数2<code>__length</code>：内存大小，单位为字节</li>
</ul>
<p>实际上这个函数并非共享内存专用，它只是一个文件相关的系统调用，用于改变文件大小，由于共享内存实际上也是一种特殊的文件，因此我们可以借助这个函数来设置文件，也就是共享内存的大小。</p>
<h4 id="2-3-3-内存映射-mmap"><a href="#2-3-3-内存映射-mmap" class="headerlink" title="2.3.3 内存映射 mmap"></a>2.3.3 内存映射 mmap</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Map addresses starting near ADDR and extending for LEN bytes.  from</span></span><br><span class="line"><span class="comment">   OFFSET into the file FD describes according to PROT and FLAGS.  If ADDR</span></span><br><span class="line"><span class="comment">   is nonzero, it is the desired mapping address.  If the MAP_FIXED bit is</span></span><br><span class="line"><span class="comment">   set in FLAGS, the mapping will be at ADDR exactly (which must be</span></span><br><span class="line"><span class="comment">   page-aligned); otherwise the system chooses a convenient nearby address.</span></span><br><span class="line"><span class="comment">   The return value is the actual mapping address chosen or MAP_FAILED</span></span><br><span class="line"><span class="comment">   for errors (in which case `errno&#x27; is set).  A successful `mmap&#x27; call</span></span><br><span class="line"><span class="comment">   deallocates any previous mapping for the affected region.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> *<span class="title function_">mmap</span> <span class="params">(<span class="type">void</span> *__addr, <span class="type">size_t</span> __len, <span class="type">int</span> __prot,</span></span><br><span class="line"><span class="params">		   <span class="type">int</span> __flags, <span class="type">int</span> __fd, <span class="type">__off_t</span> __offset)</span> __THROW;</span><br></pre></td></tr></table></figure>
<ul>
<li>功能：将文件句柄指定的文件内容映射到进程可访问到的地址空间</li>
<li>参数1<code>__addr</code>：要映射到内存区域的起始地址，通常用0，让内核来指定</li>
<li>参数2<code>__len</code>：要映射的内存区域大小，单位为字节，当大小不是4k的整数倍时，会自动扩展并以0补全</li>
<li>参数3<code>__prot</code>：期望的内存访问权限<ul>
<li><strong>PROT_EXEC</strong>：页内容可以被执行</li>
<li><strong>PROT_READ</strong>  ：页内容可以被读取</li>
<li><strong>PROT_WRITE</strong> ：页可以被写入</li>
<li><strong>PROT_NONE</strong>  ：页不可访问</li>
</ul>
</li>
<li>参数4<code>__flags</code>：指定映射对象的类型、映射选项，以及对页面的映射副本所做的修改是进程私有的还是与其他引用共享的<ul>
<li><strong>MAP_SHARED</strong> ：对映射区域的写入数据会复制回文件内, 而且允许其他映射该文件的进程共享。</li>
<li><strong>MAP_FIXED</strong> ：使用指定的映射起始地址，如果由start和len参数指定的内存区重叠于现存的映射空间，重叠部分将会被丢弃。如果指定的起始地址不可用，操作将会失败。并且起始地址必须落在页的边界上。</li>
<li><strong>MAP_PRIVATE</strong> ：建立一个写入时拷贝的私有映射。内存区域的写入不会影响到原文件。</li>
</ul>
</li>
<li>参数5<code>__fd</code>：要进行映射的文件句柄</li>
<li>参数6<code>__offset</code>：表示被映射对象（即文件）从那里开始对映，通常都是用0，需为页面大小的整数倍</li>
<li>返回值：成功时返回一个指向被映射区域首地址的指针，失败值返回-1</li>
</ul>
<h4 id="2-3-4-删除共享内存-shm-unlink"><a href="#2-3-4-删除共享内存-shm-unlink" class="headerlink" title="2.3.4 删除共享内存 shm_unlink"></a>2.3.4 删除共享内存 shm_unlink</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Remove shared memory segment.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">shm_unlink</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *__name)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>功能：删除指定名字的共享内存</li>
<li>参数1<code>__name</code>与shm_open的<code>__name</code>对应</li>
<li>返回值：成功返回0，失败返回-1</li>
</ul>
<h4 id="2-3-5-实例"><a href="#2-3-5-实例" class="headerlink" title="2.3.5 实例"></a>2.3.5 实例</h4><p>接下来可以通过一个简单的例子看看POSIX共享内存大致的使用流程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@file: alg.8-0-shmdata.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEXT_SIZE 4*1024  <span class="comment">/* = PAGE_SIZE, size of each message */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shared_struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> written; <span class="comment">/* flag = 0: buffer writable; others: readable */</span></span><br><span class="line">    <span class="type">char</span> mtext[TEXT_SIZE]; <span class="comment">/* buffer for message reading and writing */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PERM S_IRUSR|S_IWUSR|IPC_CREAT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERR_EXIT(m) \</span></span><br><span class="line"><span class="meta">    do &#123; \</span></span><br><span class="line"><span class="meta">        perror(m); \</span></span><br><span class="line"><span class="meta">        exit(EXIT_FAILURE); \</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@file: alg.8-4-shmpthreadcon.c</span></span><br><span class="line"><span class="comment">/* gcc -lrt */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;alg.8-0-shmdata.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> pathname[<span class="number">80</span>], cmd_str[<span class="number">80</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">fileattr</span>;</span></span><br><span class="line">    <span class="type">int</span> fd, shmsize, ret;</span><br><span class="line">    <span class="type">pid_t</span> childpid1, childpid2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: ./a.out filename\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = shm_open(argv[<span class="number">1</span>], O_CREAT|O_RDWR, <span class="number">0666</span>); </span><br><span class="line">        <span class="comment">/* /dev/shm/filename as the shared object, creating if not exist */</span></span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        ERR_EXIT(<span class="string">&quot;con: shm_open()&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    system(<span class="string">&quot;ls -l /dev/shm/&quot;</span>);   </span><br><span class="line">    shmsize = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> shared_struct);</span><br><span class="line">    ret = ftruncate(fd, shmsize);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        ERR_EXIT(<span class="string">&quot;con: ftruncate()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> *argv1[] = &#123;<span class="string">&quot; &quot;</span>, argv[<span class="number">1</span>], <span class="number">0</span>&#125;;</span><br><span class="line">    childpid1 = vfork();</span><br><span class="line">    <span class="keyword">if</span>(childpid1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ERR_EXIT(<span class="string">&quot;shmpthreadcon: 1st vfork()&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(childpid1 == <span class="number">0</span>) &#123;</span><br><span class="line">        execv(<span class="string">&quot;./alg.8-5-shmproducer.o&quot;</span>, argv1); <span class="comment">/* call shmproducer with filename */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        childpid2 = vfork();</span><br><span class="line">        <span class="keyword">if</span>(childpid2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ERR_EXIT(<span class="string">&quot;shmpthreadcon: 2nd vfork()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childpid2 == <span class="number">0</span>) &#123;</span><br><span class="line">            execv(<span class="string">&quot;./alg.8-6-shmconsumer.o&quot;</span>, argv1); <span class="comment">/* call shmconsumer with filename */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            wait(&amp;childpid1);</span><br><span class="line">            wait(&amp;childpid2);</span><br><span class="line">            ret = shm_unlink(argv[<span class="number">1</span>]); <span class="comment">/* shared object can be removed by any process knew the filename */</span></span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                ERR_EXIT(<span class="string">&quot;con: shm_unlink()&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            system(<span class="string">&quot;ls -l /dev/shm/&quot;</span>);   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@file: alg.8-5-shmprouducer.c</span></span><br><span class="line"><span class="comment">/* gcc -lrt */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;alg.8-0-shmdata.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd, shmsize, ret;</span><br><span class="line">    <span class="type">void</span> *shmptr;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message_0 = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    fd = shm_open(argv[<span class="number">1</span>], O_RDWR, <span class="number">0666</span>); <span class="comment">/* /dev/shm/filename as the shared object */</span></span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        ERR_EXIT(<span class="string">&quot;producer: shm_open()&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    shmsize = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> shared_struct);</span><br><span class="line">    shmptr = (<span class="type">char</span> *)mmap(<span class="number">0</span>, shmsize, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(shmptr == (<span class="type">void</span> *)<span class="number">-1</span>) &#123;</span><br><span class="line">        ERR_EXIT(<span class="string">&quot;producer: mmap()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;producer: shared memory attached at %p\n&quot;</span>, shmptr);</span><br><span class="line">    <span class="built_in">sprintf</span>(shmptr,<span class="string">&quot;%s&quot;</span>,message_0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;produced message: %s\n&quot;</span>, (<span class="type">char</span> *)shmptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@file: alg.8-6-shmconsumer.c</span></span><br><span class="line"><span class="comment">/* gcc -lrt */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;alg.8-0-shmdata.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd, shmsize;</span><br><span class="line">    <span class="type">void</span> *shmptr;</span><br><span class="line">    </span><br><span class="line">    fd = shm_open(argv[<span class="number">1</span>], O_RDONLY, <span class="number">0444</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        ERR_EXIT(<span class="string">&quot;consumer: shm_open()&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    shmsize = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> shared_struct);</span><br><span class="line">    shmptr = (<span class="type">char</span> *)mmap(<span class="number">0</span>, shmsize, PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(shmptr == (<span class="type">void</span> *)<span class="number">-1</span>) &#123;</span><br><span class="line">        ERR_EXIT(<span class="string">&quot;consumer: mmap()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;consumer: shared memory attached at %p\n&quot;</span>, shmptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;consumed message: %s\n&quot;</span>, (<span class="type">char</span> *)shmptr);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%85%E6%9E%90System%20V%E5%92%8CPOSIX%E4%B8%8B%E7%9A%84IPC/选区_012.png" alt="选区_012"></p>
<h3 id="2-4-比较"><a href="#2-4-比较" class="headerlink" title="2.4 比较"></a>2.4 比较</h3><p>POSIX相比System V一个比较好的优点在于不需要通过ftok函数将文件转化得到一个key值，而是直接利用文件名即可，这也是后面消息传递POSIX相较System V的一个优点。</p>
<h2 id="3-消息传递-Message-Passing"><a href="#3-消息传递-Message-Passing" class="headerlink" title="3. 消息传递 Message Passing"></a>3. 消息传递 Message Passing</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>​        共享内存虽然速度快，但它可能会面临着同步的问题，这个时候，消息传递机制就可以自动地解决。</p>
<p>​        我们可以从下图看出两者的一个区别，共享内存实际上就是操作系统给进程分配了一块内存，然后至于进程要怎么去处理这块内存，操作系统不会再进行干预。而消息传递会将消息按队列的方式进行组织，通常时FIFO，但也可以带有优先级。</p>
<p><img src="/2022/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%85%E6%9E%90System%20V%E5%92%8CPOSIX%E4%B8%8B%E7%9A%84IPC/选区_005.png" alt="选区_005"></p>
<p>​    Linux下的消息结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> &#123;</span></span><br><span class="line">	<span class="type">long</span> <span class="type">int</span> msg_type;</span><br><span class="line">	<span class="type">char</span> mtext[TEXT_SIZE];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    消息队列结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> &#123;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span>  <span class="title">ipc_perm</span> <span class="title">msg_perm</span>;</span>	     <span class="comment">/*	msg queue permission bits */</span></span><br><span class="line">     <span class="type">msglen_t</span> msg_cbytes;    <span class="comment">/*	number of bytes	in use on the queue */</span></span><br><span class="line">     <span class="type">msgqnum_t</span> msg_qnum;     <span class="comment">/*	number of msgs in the queue */</span></span><br><span class="line">     <span class="type">msglen_t</span> msg_qbytes;    <span class="comment">/*	max # of bytes on the queue */</span></span><br><span class="line">     <span class="type">pid_t</span>   msg_lspid;	     <span class="comment">/*	pid of last msgsnd() */</span></span><br><span class="line">     <span class="type">pid_t</span>   msg_lrpid;	     <span class="comment">/*	pid of last msgrcv() */</span></span><br><span class="line">     <span class="type">time_t</span>  msg_stime;	     <span class="comment">/*	time of	last msgsnd() */</span></span><br><span class="line">     <span class="type">time_t</span>  msg_rtime;	     <span class="comment">/*	time of	last msgrcv() */</span></span><br><span class="line">     <span class="type">time_t</span>  msg_ctime;	     <span class="comment">/*	time of	last msgctl() */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> &#123;</span></span><br><span class="line">     <span class="type">uid_t</span>	     cuid;   <span class="comment">/*	creator	user id	*/</span></span><br><span class="line">     <span class="type">gid_t</span>	     cgid;   <span class="comment">/*	creator	group id */</span></span><br><span class="line">     <span class="type">uid_t</span>	     uid;    <span class="comment">/*	user id	*/</span></span><br><span class="line">     <span class="type">gid_t</span>	     gid;    <span class="comment">/*	group id */</span></span><br><span class="line">     <span class="type">mode_t</span>	     mode;   <span class="comment">/*	r/w permission */</span></span><br><span class="line">     <span class="type">unsigned</span> <span class="type">short</span>  seq;    <span class="comment">/*	sequence # (to generate	unique ipcid) */</span></span><br><span class="line">     <span class="type">key_t</span>	     key;    <span class="comment">/*	user specified msg/sem/shm key */</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-System-V"><a href="#3-2-System-V" class="headerlink" title="3.2 System V"></a>3.2 System V</h3><p>#include <sys msg.h></sys></p>
<h4 id="3-2-1-创建-获取消息队列-msgget"><a href="#3-2-1-创建-获取消息队列-msgget" class="headerlink" title="3.2.1 创建/获取消息队列 msgget"></a>3.2.1 创建/获取消息队列 msgget</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get messages queue.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">msgget</span> <span class="params">(<span class="type">key_t</span> __key, <span class="type">int</span> __msgflg)</span> __THROW;</span><br></pre></td></tr></table></figure>
<ul>
<li>功能：得到消息队列标识符或创建一个消息队列对象</li>
<li>参数1<code>__key</code>：由ftok函数产生的键值</li>
<li>参数2<code>__msgflg</code>：标志位，同样可取IPC_CREAT、IPC_EXCL等值</li>
<li>返回值：成功返回消息队列的id，失败返回-1</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">ksys_msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipc_ops</span> <span class="title">msg_ops</span> =</span> &#123;</span><br><span class="line">		.getnew = newque,</span><br><span class="line">		.associate = security_msg_queue_associate,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_params</span> <span class="title">msg_params</span>;</span></span><br><span class="line"></span><br><span class="line">	ns = current-&gt;nsproxy-&gt;ipc_ns;</span><br><span class="line"></span><br><span class="line">	msg_params.key = key;</span><br><span class="line">	msg_params.flg = msgflg;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ipcget(ns, &amp;msg_ids(ns), &amp;msg_ops, &amp;msg_params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是msgget的实现，可以看到最终跟shmget一样，都是去调用ipcget获取一个ipc对象，不同只是在于传入的参数</p>
<h4 id="3-2-2-发送消息-msgsnd"><a href="#3-2-2-发送消息-msgsnd" class="headerlink" title="3.2.2 发送消息  msgsnd"></a>3.2.2 发送消息  msgsnd</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">msgsnd</span> <span class="params">(<span class="type">int</span> __msqid, <span class="type">const</span> <span class="type">void</span> *__msgp, <span class="type">size_t</span> __msgsz, <span class="type">int</span> __msgflg)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>功能：向指定的消息队列中投放消息</p>
</li>
<li><p>参数1<code>__msqid</code>：消息队列的id</p>
</li>
<li><p>参数2<code>__msgp</code>：指向包含消息结构体的指针，该结构必须包含消息头和消息体</p>
</li>
<li><p>参数3<code>__msgsz</code>：消息的大小</p>
<p><img src="/2022/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%85%E6%9E%90System%20V%E5%92%8CPOSIX%E4%B8%8B%E7%9A%84IPC/选区_003.png" alt="选区_003"></p>
</li>
<li><p>参数4<code>__msgflg</code>：如果将要发送的消息已经放不进队列中了，那么会由此参数决定msgsnd的行为，实际上就是决定是阻塞发送或非阻塞发送</p>
<ul>
<li>IPC_NOWAIT：非阻塞发送，此时会立即返回</li>
<li>若没有IPC_NOWAIT，即传入0，则为阻塞发送，它会阻塞直到：<ul>
<li>消息可以发送出去</li>
<li>消息队列被删除</li>
<li>调用者获取到信号</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：成功返回0，失败返回-1</p>
<p>可以看一下msgsnd的实现，我们传入的消息是作为msgp传到了ksys_msgsnd中，msgp是一个msgbuf类型的指针，宏定义__user表明这个指针地址来自用户空间，所以我们还需要通过get_user从用户空间拷贝mtype到内核空间，以及do_msgsnd函数里面有一个<code>msg = load_msg(mtext, msgsz);</code>，也是去从用户空间拷贝消息内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">ksys_msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="keyword">struct</span> msgbuf __user *msgp, <span class="type">size_t</span> msgsz,</span></span><br><span class="line"><span class="params">		 <span class="type">int</span> msgflg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> mtype;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (get_user(mtype, &amp;msgp-&gt;mtype))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	<span class="keyword">return</span> do_msgsnd(msqid, mtype, msgp-&gt;mtext, msgsz, msgflg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下所示，mtype是一个大于0的整数，可用于接收方做消息的筛选，mtext用于存储消息，它类似于一个柔性数组，是可以扩展大小的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* message buffer for msgsnd and msgrcv calls */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">	<span class="type">__kernel_long_t</span> mtype;          <span class="comment">/* type of message */</span></span><br><span class="line">	<span class="type">char</span> mtext[<span class="number">1</span>];                  <span class="comment">/* message text */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-2-3-接收消息-msgrcv"><a href="#3-2-3-接收消息-msgrcv" class="headerlink" title="3.2.3 接收消息 msgrcv"></a>3.2.3 接收消息 msgrcv</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">ssize_t</span> <span class="title function_">msgrcv</span> <span class="params">(<span class="type">int</span> __msqid, <span class="type">void</span> *__msgp, <span class="type">size_t</span> __msgsz,</span></span><br><span class="line"><span class="params">		       <span class="type">long</span> <span class="type">int</span> __msgtyp, <span class="type">int</span> __msgflg)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>功能：从指定消息队列中获取消息</p>
</li>
<li><p>参数1<code>__msqid</code>：消息队列id</p>
</li>
<li><p>参数2<code>__msgp</code>：指向存放消息的结构体的指针，是一个接收参数</p>
</li>
<li><p>参数3<code>__msgsz</code>：接收消息的结构体大小</p>
</li>
<li><p>参数4<code>__msgtyp</code>：指定接收消息的类型</p>
<ul>
<li>若为0，则接收队列中的第一个消息</li>
<li>若大于0，则接收队列中第一个类型为__msgtyp的消息</li>
<li>若小于0，则接收小于msgtyp绝对值的最低消息类型的第一条消息。</li>
</ul>
<p>比如传入-4，现有队列中有1，2，3三种类型消息，则会接收类型1的第一条消息</p>
<p>如下是msgrcv实现过程中对于msgtype的处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">convert_mode</span><span class="params">(<span class="type">long</span> *msgtyp, <span class="type">int</span> msgflg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (msgflg &amp; MSG_COPY)</span><br><span class="line">		<span class="keyword">return</span> SEARCH_NUMBER;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *  find message of correct type.</span></span><br><span class="line"><span class="comment">	 *  msgtyp = 0 =&gt; get first.</span></span><br><span class="line"><span class="comment">	 *  msgtyp &gt; 0 =&gt; get first message of matching type.</span></span><br><span class="line"><span class="comment">	 *  msgtyp &lt; 0 =&gt; get message with least type must be &lt; abs(msgtype).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (*msgtyp == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> SEARCH_ANY;</span><br><span class="line">	<span class="keyword">if</span> (*msgtyp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*msgtyp == LONG_MIN) <span class="comment">/* -LONG_MIN is undefined */</span></span><br><span class="line">			*msgtyp = LONG_MAX;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			*msgtyp = -*msgtyp;</span><br><span class="line">		<span class="keyword">return</span> SEARCH_LESSEQUAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (msgflg &amp; MSG_EXCEPT)</span><br><span class="line">		<span class="keyword">return</span> SEARCH_NOTEQUAL;</span><br><span class="line">	<span class="keyword">return</span> SEARCH_EQUAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数5<code>__msgflg</code>：标志位</p>
<ul>
<li>当__msgsz小于将要接收的消息大小时，若设置了MSG_NOERROR，则消息被截断，否则报错</li>
<li>同样可以跟msgsnd一样由IPC_NOWAIT决定是否阻塞</li>
</ul>
</li>
<li><p>返回值：成功则返回所接收消息的大小，失败返回-1</p>
</li>
</ul>
<h4 id="3-2-4-消息队列控制-msgctl"><a href="#3-2-4-消息队列控制-msgctl" class="headerlink" title="3.2.4 消息队列控制 msgctl"></a>3.2.4 消息队列控制 msgctl</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Message queue control operation.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">msgctl</span> <span class="params">(<span class="type">int</span> __msqid, <span class="type">int</span> __cmd, <span class="keyword">struct</span> msqid_ds *__buf)</span> __THROW;</span><br></pre></td></tr></table></figure>
<ul>
<li>功能：对指定的消息队列进行一系列操作</li>
<li>参数1<code>__msqid</code>：消息队列的id</li>
<li>参数2<code>__cmd</code>：操作命令<ul>
<li>IPC_STAT：获取消息队列的信息</li>
<li>IPC_SET：设置msg_perm中的uid、gid、mode、qbytes，其中qbytes只能由超级用户进行递增，且若qbytes的大小超过系统限制的是否会被截断</li>
<li>IPC_RMID：删除消息队列，只有超级用户、或拥有该消息队列的用户才能删除</li>
</ul>
</li>
<li>参数3<code>__buf</code>：作为IPC_STAT对应的接收参数或作为IPC_SET的传入参数</li>
</ul>
<h4 id="3-2-5-实例"><a href="#3-2-5-实例" class="headerlink" title="3.2.5 实例"></a>3.2.5 实例</h4><p>我们传递的消息的结构实际上是我们自己定义的，前面提到消息的结构必须包括</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">__kernel_long_t</span> mtype;          <span class="comment">/* type of message */</span></span><br><span class="line"><span class="type">char</span> mtext[<span class="number">1</span>];                  <span class="comment">/* message text */</span></span><br></pre></td></tr></table></figure>
<p>那除了这两个，能否再加上其他的变量呢，可以通过下面一个实例进行一下试验，通过这个例子也能够大致体现消息队列是如何使用的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@file: alg.9-0-msgdata.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEXT_SIZE 512</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* message structure */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> msg_type;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> mtext[TEXT_SIZE]; <span class="comment">/* binary data */</span></span><br><span class="line">    <span class="type">int</span> num1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERR_EXIT(m) \</span></span><br><span class="line"><span class="meta">    do &#123; \</span></span><br><span class="line"><span class="meta">        perror(m); \</span></span><br><span class="line"><span class="meta">        exit(EXIT_FAILURE); \</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@file: alg.9-1-msgsnd.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;alg.9-0-msgdata.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> pathname[<span class="number">80</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">fileattr</span>;</span></span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_struct</span> <span class="title">data</span>;</span></span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> msg_type;</span><br><span class="line">    <span class="type">char</span> buffer[TEXT_SIZE];</span><br><span class="line">    <span class="type">int</span> num, num1;</span><br><span class="line">    <span class="type">int</span> msqid, ret, count = <span class="number">0</span>;</span><br><span class="line">    FILE *fp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(pathname, <span class="string">&quot;/home/huanghj/mymq&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(stat(pathname, &amp;fileattr) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ret = creat(pathname, O_RDWR);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            ERR_EXIT(<span class="string">&quot;creat()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;shared file object created\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    key = ftok(pathname, <span class="number">0x27</span>); <span class="comment">/* project_id can be any nonzero integer */</span></span><br><span class="line">    <span class="keyword">if</span>(key &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ERR_EXIT(<span class="string">&quot;ftok()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nIPC key = 0x%x\n&quot;</span>, key);	</span><br><span class="line">    </span><br><span class="line">    msqid = msgget((<span class="type">key_t</span>)key, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span>(msqid == <span class="number">-1</span>) &#123;</span><br><span class="line">        ERR_EXIT(<span class="string">&quot;msgget()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    fp = fopen(<span class="string">&quot;./alg.9-0-msgsnd.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!fp) &#123;</span><br><span class="line">        ERR_EXIT(<span class="string">&quot;source data file: ./msgsnd.txt fopen()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> <span class="title">msqattr</span>;</span></span><br><span class="line">    ret = msgctl(msqid, IPC_STAT, &amp;msqattr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Blocking Sending ... \n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (!feof(fp)) &#123;</span><br><span class="line">        ret = <span class="built_in">fscanf</span>(fp, <span class="string">&quot;%ld %s %d %d&quot;</span>, &amp;msg_type, buffer, &amp;num, &amp;num1);</span><br><span class="line">        <span class="keyword">if</span>(ret == EOF) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%ld %s %d %d\n&quot;</span>, msg_type, buffer, num, num1);</span><br><span class="line">                        </span><br><span class="line">        data.msg_type = msg_type;</span><br><span class="line">        <span class="built_in">strcpy</span>(data.mtext, buffer);</span><br><span class="line">        data.num = num;</span><br><span class="line">        data.num1 = num1;</span><br><span class="line"></span><br><span class="line">        ret = msgsnd(msqid, (<span class="type">void</span> *)&amp;data, TEXT_SIZE, <span class="number">0</span>); <span class="comment">/* 0: blocking send, waiting when msg queue is full */</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            ERR_EXIT(<span class="string">&quot;msgsnd()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        system(<span class="string">&quot;ipcs -q&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;number of sent messages = %d\n&quot;</span>, count);</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">    system(<span class="string">&quot;ipcs -q&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@file:  alg.9-2-msgrcv.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;alg.9-0-msgdata.h&quot;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> <span class="comment">/* Usage: ./b.out msg_type */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">fileattr</span>;</span></span><br><span class="line">    <span class="type">char</span> pathname[<span class="number">80</span>];</span><br><span class="line">    <span class="type">int</span> msqid, ret, count = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_struct</span> <span class="title">data</span>;</span></span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> msgtype = <span class="number">0</span>;   <span class="comment">/* 0 - type of any messages */</span>  </span><br><span class="line"> </span><br><span class="line">    msgtype = atol(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(pathname, <span class="string">&quot;/home/huanghj/mymq&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(stat(pathname, &amp;fileattr) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ERR_EXIT(<span class="string">&quot;shared file object stat error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((key = ftok(pathname, <span class="number">0x27</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ERR_EXIT(<span class="string">&quot;ftok()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nIPC key = 0x%x\n&quot;</span>, key);</span><br><span class="line"></span><br><span class="line">    msqid = msgget((<span class="type">key_t</span>)key, <span class="number">0666</span>); <span class="comment">/* do not create a new msg queue */</span></span><br><span class="line">    <span class="keyword">if</span>(msqid == <span class="number">-1</span>) &#123;</span><br><span class="line">        ERR_EXIT(<span class="string">&quot;msgget()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sleeping_time = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ret = msgrcv(msqid, (<span class="type">void</span> *)&amp;data, TEXT_SIZE, msgtype, IPC_NOWAIT); <span class="comment">/* Non_blocking receive */</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123; <span class="comment">/* end of this msgtype */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;number of received messages = %d\n&quot;</span>, count);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%ld %s %d %d\n&quot;</span>, data.msg_type, data.mtext, data.num, data.num1);</span><br><span class="line">        count++;</span><br><span class="line">        system(<span class="string">&quot;ipcs -q&quot;</span>);</span><br><span class="line">        sleep(sleeping_time);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> <span class="title">msqattr</span>;</span></span><br><span class="line">    ret = msgctl(msqid, IPC_STAT, &amp;msqattr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;number of messages remainding = %ld\n&quot;</span>, msqattr.msg_qnum); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(msqattr.msg_qnum == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;do you want to delete this msg queue?(y/n)&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(getchar() == <span class="string">&#x27;y&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(msgctl(msqid, IPC_RMID, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">                perror(<span class="string">&quot;msgctl(IPC_RMID)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">&quot;ipcs -q&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%85%E6%9E%90System%20V%E5%92%8CPOSIX%E4%B8%8B%E7%9A%84IPC/选区_015.png" alt="选区_014"></p>
<h3 id="3-3-POSIX"><a href="#3-3-POSIX" class="headerlink" title="3.3 POSIX"></a>3.3 POSIX</h3><p>引用<mqueue.h></mqueue.h></p>
<h4 id="3-3-1-创建-获取消息队列-mq-open"><a href="#3-3-1-创建-获取消息队列-mq-open" class="headerlink" title="3.3.1 创建/获取消息队列 mq_open"></a>3.3.1 创建/获取消息队列 mq_open</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Establish connection between a process and a message queue NAME and</span></span><br><span class="line"><span class="comment">   return message queue descriptor or (mqd_t) -1 on error.  OFLAG determines</span></span><br><span class="line"><span class="comment">   the type of access used.  If O_CREAT is on OFLAG, the third argument is</span></span><br><span class="line"><span class="comment">   taken as a `mode_t&#x27;, the mode of the created message queue, and the fourth</span></span><br><span class="line"><span class="comment">   argument is taken as `struct mq_attr *&#x27;, pointer to message queue</span></span><br><span class="line"><span class="comment">   attributes.  If the fourth argument is NULL, default attributes are</span></span><br><span class="line"><span class="comment">   used.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">mqd_t</span> <span class="title function_">mq_open</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *__name, <span class="type">int</span> __oflag, ...)</span></span><br><span class="line">  __THROW __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>))</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>功能：创建或获取指定名字的消息队列</li>
<li>参数1<code>__name</code>：消息队列的名字</li>
<li>参数2<code>__oflag</code>：对消息队列的标志位及打开方式，包括<ul>
<li>O_RDONLY</li>
<li>O_WRONLY</li>
<li>O_RDWR</li>
<li>O_CREAT</li>
<li>O_EXCL</li>
<li>O_NONBLOCK</li>
</ul>
</li>
</ul>
<p>可选参数实际是以下两个参数，它们在创建新消息队列的时候才会起作用，也可以不传入，此时则会以默认值创建新消息队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">mqd_t</span> <span class="title function_">mq_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflag, <span class="type">mode_t</span> mode, <span class="keyword">struct</span> mq_attr *attr)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数3<code>mode</code>：新建消息队列的访问权限</p>
</li>
<li><p>参数4<code>attr</code>：新建消息队列自定义属性</p>
<p>mq_attr结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mq_attr</span> &#123;</span></span><br><span class="line">               <span class="type">long</span> mq_flags;       <span class="comment">/* Flags (ignored for mq_open()) */</span></span><br><span class="line">               <span class="type">long</span> mq_maxmsg;      <span class="comment">/* Max. # of messages on queue */</span></span><br><span class="line">               <span class="type">long</span> mq_msgsize;     <span class="comment">/* Max. message size (bytes) */</span></span><br><span class="line">               <span class="type">long</span> mq_curmsgs;     <span class="comment">/* # of messages currently in queue</span></span><br><span class="line"><span class="comment">                                       (ignored for mq_open()) */</span></span><br><span class="line">           &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回值：成功则返回消息队列的描述符，失败返回-1</p>
</li>
</ul>
<h4 id="3-3-2-关闭消息队列-mq-closse"><a href="#3-3-2-关闭消息队列-mq-closse" class="headerlink" title="3.3.2 关闭消息队列 mq_closse"></a>3.3.2 关闭消息队列 mq_closse</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mq_close</span><span class="params">(<span class="type">mqd_t</span> mqdes)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>功能：关闭指定的消息队列，即解除于该消息队列的绑定，并不会进行删除</li>
<li>参数1<code>mqdes</code>：消息队列描述符</li>
<li>返回值：成功返回0，失败返回-1</li>
</ul>
<h4 id="3-3-3-发送消息-mq-send"><a href="#3-3-3-发送消息-mq-send" class="headerlink" title="3.3.3 发送消息 mq_send"></a>3.3.3 发送消息 mq_send</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mq_send</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="type">const</span> <span class="type">char</span> *msg_ptr,</span></span><br><span class="line"><span class="params">                     <span class="type">size_t</span> msg_len, <span class="type">unsigned</span> <span class="type">int</span> msg_prio)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>功能：向指定消息队列投放消息</p>
</li>
<li><p>参数1<code>mqdes</code>：消息队列标识符</p>
</li>
<li><p>参数2<code>msg_ptr</code>：指向消息的指针</p>
</li>
<li><p>参数3<code>msg_len</code>：消息长度</p>
</li>
<li><p>参数4<code>msg_prio</code>：消息优先级，与System V一样，为非负整数（System V不能为0）</p>
</li>
<li><p>返回值：成功返回0，失败返回-1</p>
<p>消息会按优先级从高到低（0为最低）的顺序存放在消息队列中，若优先级相同则以进入队列的时间先后排序，先进队列在前</p>
</li>
</ul>
<p>消息队列为满时，默认是阻塞发送，除非使用mq_open()时传入O_NONBLOCK</p>
<p>如果没有传O_NONBLOCK，其实还要另一种做法，那就是使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mq_timedsend</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="type">const</span> <span class="type">char</span> *msg_ptr,</span></span><br><span class="line"><span class="params">                     <span class="type">size_t</span> msg_len, <span class="type">unsigned</span> <span class="type">int</span> msg_prio,</span></span><br><span class="line"><span class="params">                     <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">               <span class="type">time_t</span> tv_sec;        <span class="comment">/* seconds */</span></span><br><span class="line">               <span class="type">long</span>   tv_nsec;       <span class="comment">/* nanoseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在指定时间内为能写入成功则会立即返回</p>
<h4 id="3-3-4-接收消息-mq-receive"><a href="#3-3-4-接收消息-mq-receive" class="headerlink" title="3.3.4 接收消息 mq_receive"></a>3.3.4 接收消息 mq_receive</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">mq_receive</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="type">char</span> *msg_ptr,</span></span><br><span class="line"><span class="params">                         <span class="type">size_t</span> msg_len, <span class="type">unsigned</span> <span class="type">int</span> *msg_prio)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>功能：从指定消息队列中获取<strong>队首</strong>消息</p>
</li>
<li><p>参数1<code>mqdes</code>：消息队列描述符</p>
</li>
<li><p>参数2<code>msg_ptr</code>：接收参数，指向一块存放接收消息的空间</p>
</li>
<li><p>参数3<code>msg_len</code>：接收空间大小</p>
</li>
<li><p>参数4<code>msg_prio</code>：<strong>接收参数</strong>，指向一块存放接收消息优先级的空间</p>
<p>msg_prio区别于msgrcv，并非指定接收消息的优先级，而是作为一个接收参数，返回所接收到的消息的优先级，这是与System V的另一个区别</p>
</li>
<li><p>返回值：成功返回接收消息的大小，失败返回-1</p>
</li>
</ul>
<p>与mq_send一样，默认是阻塞，除非设置了O_NONBLOCK</p>
<p>同样也有类似的函数用于超时返回</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">mq_timedreceive</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="type">char</span> *<span class="keyword">restrict</span> msg_ptr,</span></span><br><span class="line"><span class="params">                          <span class="type">size_t</span> msg_len, <span class="type">unsigned</span> <span class="type">int</span> *<span class="keyword">restrict</span> msg_prio,</span></span><br><span class="line"><span class="params">                          <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abs_timeout)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-5-消息队列属性相关-mq-setattr-mq-getattr"><a href="#3-3-5-消息队列属性相关-mq-setattr-mq-getattr" class="headerlink" title="3.3.5 消息队列属性相关 mq_setattr mq_getattr"></a>3.3.5 消息队列属性相关 mq_setattr mq_getattr</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mq_getattr</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="keyword">struct</span> mq_attr *attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mq_setattr</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="type">const</span> <span class="keyword">struct</span> mq_attr *<span class="keyword">restrict</span> newattr,</span></span><br><span class="line"><span class="params">                      <span class="keyword">struct</span> mq_attr *<span class="keyword">restrict</span> oldattr)</span>;</span><br></pre></td></tr></table></figure>
<p>mq_setattr实际上只能改变mq_flags</p>
<h4 id="3-3-6-异步事件通知-mq-notify"><a href="#3-3-6-异步事件通知-mq-notify" class="headerlink" title="3.3.6 异步事件通知 mq_notify"></a>3.3.6 异步事件通知 mq_notify</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mq_notify</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="type">const</span> <span class="keyword">struct</span> sigevent* notification)</span>;</span><br></pre></td></tr></table></figure>
<p>POSIX消息队列相比于System V的一个优点在于它支持异步事件通知，即当一个空的消息队列被放置入消息之后可以通知注册的相关进程，这个通知有两种形式：</p>
<ol>
<li>产生一个信号</li>
<li>创建一个线程来执行一个特定程序</li>
</ol>
<p>mq_notify函数就是实现通知注册以及注销的功能</p>
<ul>
<li>参数1<code>mqdes</code>：消息队列描述符</li>
<li>参数2<code>notification</code>：当该参数为空时，为注销功能，不为空则为注册功能</li>
<li>返回值：成功返回0，失败返回-1</li>
</ul>
<p>sigevent结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>    sigev_notify;      <span class="comment">/* 设置通知机制方法，线程为SIGEV_THREAD，信号为SIGEV_SIGNAL*/</span></span><br><span class="line">    <span class="type">int</span>    sigev_signo;       <span class="comment">/* 若是信号机制，该参数设置为触发的信号 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">sigval</span> <span class="title">sigev_value</span>;</span><span class="comment">/* 传递的参数*/</span></span><br><span class="line">    <span class="type">void</span> (*sigev_notify_function)(<span class="keyword">union</span> sigval); <span class="comment">/* 若是线程机制，该参数为线程函数*/</span></span><br><span class="line">    <span class="type">void</span>  *sigev_notify_attributes; <span class="comment">/* 线程函数的属性 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">sigval</span> &#123;</span>               <span class="comment">/*传递的参数*/</span></span><br><span class="line">    <span class="type">int</span>     sival_int;        <span class="comment">/* 信号机制传递的参数 */</span></span><br><span class="line">    <span class="type">void</span>   *sival_ptr;        <span class="comment">/* 若是线程机制传递的参数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意若注册之后，通过mq_close关闭了消息队列，则注册会自动解除</p>
<p>使用例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@file: mq_notify_test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> handle_error(msg) \</span></span><br><span class="line"><span class="meta">    do &#123; perror(msg); exit(EXIT_FAILURE); &#125; while (0)</span></span><br><span class="line"><span class="comment">/* Thread start function */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tfunc</span><span class="params">(<span class="keyword">union</span> sigval sv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mq_attr</span> <span class="title">attr</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> nr;</span><br><span class="line">    <span class="type">void</span> *buf;</span><br><span class="line">    <span class="type">mqd_t</span> mqdes = *((<span class="type">mqd_t</span> *) sv.sival_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Determine max. msg size; allocate buffer to receive msg */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mq_getattr(mqdes, &amp;attr) == <span class="number">-1</span>)</span><br><span class="line">        handle_error(<span class="string">&quot;mq_getattr&quot;</span>);</span><br><span class="line">    buf = <span class="built_in">malloc</span>(attr.mq_msgsize);</span><br><span class="line">    <span class="keyword">if</span> (buf == <span class="literal">NULL</span>)</span><br><span class="line">        handle_error(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    nr = mq_receive(mqdes, buf, attr.mq_msgsize, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (nr == <span class="number">-1</span>)</span><br><span class="line">        handle_error(<span class="string">&quot;mq_receive&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Read %zd bytes from MQ\n&quot;</span>, nr);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);         <span class="comment">/* Terminate the process */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">mqd_t</span> mqdes;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">sev</span>;</span></span><br><span class="line"></span><br><span class="line">    mqdes = mq_open(<span class="string">&quot;/mqtest&quot;</span>, O_RDONLY|O_CREAT, <span class="number">0666</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (mqdes == (<span class="type">mqd_t</span>) <span class="number">-1</span>)</span><br><span class="line">        handle_error(<span class="string">&quot;mq_open&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sev.sigev_notify = SIGEV_THREAD;</span><br><span class="line">    sev.sigev_notify_function = tfunc;</span><br><span class="line">    sev.sigev_notify_attributes = <span class="literal">NULL</span>;</span><br><span class="line">    sev.sigev_value.sival_ptr = &amp;mqdes;   <span class="comment">/* Arg. to thread func. */</span></span><br><span class="line">    <span class="keyword">if</span> (mq_notify(mqdes, &amp;sev) == <span class="number">-1</span>)</span><br><span class="line">        handle_error(<span class="string">&quot;mq_notify&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pause();    <span class="comment">/* Process will be terminated by thread function */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@file: mq_notify_test_write.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> handle_error(msg) \</span></span><br><span class="line"><span class="meta">    do &#123; perror(msg); exit(EXIT_FAILURE); &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">mqd_t</span> mqdes;</span><br><span class="line">    mqdes = mq_open(<span class="string">&quot;/mqtest&quot;</span>, O_RDWR, <span class="number">0666</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (mqdes == (<span class="type">mqd_t</span>) <span class="number">-1</span>)</span><br><span class="line">        handle_error(<span class="string">&quot;mq_open&quot;</span>);</span><br><span class="line">    <span class="type">char</span> msg[<span class="number">100</span>] = <span class="string">&quot;hello!&quot;</span>;</span><br><span class="line">    <span class="type">int</span> ret = mq_send(mqdes, msg, <span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == (<span class="type">mqd_t</span>) <span class="number">-1</span>)</span><br><span class="line">        handle_error(<span class="string">&quot;mq_open&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%85%E6%9E%90System%20V%E5%92%8CPOSIX%E4%B8%8B%E7%9A%84IPC/选区_010.png" alt="选区_010"></p>
<h4 id="3-3-7-删除消息队列-mq-unlink"><a href="#3-3-7-删除消息队列-mq-unlink" class="headerlink" title="3.3.7 删除消息队列 mq_unlink"></a>3.3.7 删除消息队列 mq_unlink</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mq_unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数1<code>name</code>：消息队列的名称</li>
<li>返回值：成功返回0，失败返回-1</li>
</ul>
<h3 id="3-4-比较"><a href="#3-4-比较" class="headerlink" title="3.4 比较"></a>3.4 比较</h3><p>这里可以将System V和POSIX的消息队列做一个简单的比较，主要区别有两个：</p>
<ul>
<li>System V支持消息类型的筛选，而POSIX每次只能读取队首消息，但是队列会自动按消息的优先级将消息进行排序</li>
<li>POSIX支持异步事件处理</li>
</ul>
<h2 id="4-管道"><a href="#4-管道" class="headerlink" title="4. 管道"></a>4. 管道</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p>​        管道作为最古老的一种通信方式，在Unix开发期间就被提出。但它现在仍然是使用频率非常高的一种IPC，就比如我们常用的管道操作符<code>|</code>，它连接了多个进程，前一个进程将命令执行的输出结果作为输入通过管道传到后一个进程，从而能够实现一系列复杂的指令操作。</p>
<p>​        管道是一种特殊的文件，可以通过它的文件句柄对其进行访问，因此我们同样可以通过read()和write()系统调用来实现读写，由于是通过read()和write()，因此管道是基于字节流的读写，那么便可以无结构化地以任意大小来进行读写。    </p>
<p>​        其实管道相比消息队列来说，更像一个队列，因为它就是严格的单向通信，并且遵从先进先出。这里的单向我们可以类比水管来理解，在只有一条水管的情况下，水只能从高的一端流向低的一端，当然，两端是谁在接水是无所谓的（也就是说每个进程都可以作为接受方或发送方，只要拿得到句柄即可），但是同一时间一定只能一方接得到水，即<strong>半双工</strong>。因此，要实现像聊天一样，必须得有两条管道。</p>
<p>​            </p>
<h3 id="4-2-匿名管道"><a href="#4-2-匿名管道" class="headerlink" title="4.2 匿名管道"></a>4.2 匿名管道</h3><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <unistd.h></unistd.h></h1><p>​        匿名管道由于没有一个绑定的键值，故多用于有关联的进程之间，如父子或兄弟进程。</p>
<h4 id="4-2-1-创建管道pipe"><a href="#4-2-1-创建管道pipe" class="headerlink" title="4.2.1 创建管道pipe"></a>4.2.1 创建管道pipe</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a one-way communication channel (pipe).</span></span><br><span class="line"><span class="comment">   If successful, two file descriptors are stored in PIPEDES;</span></span><br><span class="line"><span class="comment">   bytes written on PIPEDES[1] can be read from PIPEDES[0].</span></span><br><span class="line"><span class="comment">   Returns 0 if successful, -1 if not.  */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>功能：创建一个匿名管道并返回一个读句柄和一个写句柄</li>
<li>参数<code>pipefd</code>为接收参数，其中pipefd[0]为读句柄，pipefd[1]为写句柄</li>
<li>返回值：成功返回0，失败返回-1，失败的时候不会改变pipefd中的值</li>
</ul>
<p>创建管道还有另外一个函数pipe2()，它增加了一个标志位参数，当flags传入0的时候，与pipe没有差别</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pipe2</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>], <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数<code>flags</code>：</p>
<ul>
<li>O_CLOEXEC：close-on-exec，这个标志位在open()中也有，因为管道实际上是一种特殊的文件。它的作用在于当进程通过execve()系统调用开启新进程的时候，原本的文件描述符会被自动关闭，从而避免文件的泄漏。那么迁移到pipe，也就是说当不希望通过execve()切换的新进程用到该匿名管道的时候，便可以使用该标志位。</li>
<li>O_NONBLOCK：设置非阻塞读写</li>
</ul>
</li>
</ul>
<h4 id="4-2-2-写入消息-write"><a href="#4-2-2-写入消息-write" class="headerlink" title="4.2.2 写入消息 write"></a>4.2.2 写入消息 write</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sszie_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">1</span>], <span class="type">void</span>* buf, <span class="type">size_t</span> count)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>功能：往管道的写端写入消息</li>
<li>参数1<code>pipefd[1]</code>：写句柄</li>
<li>参数2<code>buf</code>：写入的消息</li>
<li><p>参数3<code>count</code>：写入消息大小</p>
</li>
<li><p>返回值：成功则返回实际写入的消息大小，失败返回-1</p>
</li>
</ul>
<h4 id="4-2-3-读出消息-read"><a href="#4-2-3-读出消息-read" class="headerlink" title="4.2.3 读出消息 read"></a>4.2.3 读出消息 read</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">0</span>], <span class="type">void</span>* buf, <span class="type">size_t</span> count)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>功能：从管道的读端读出消息</li>
<li>参数1<code>pipefd[0]</code>：读句柄</li>
<li>参数2<code>buf</code>：存放读出的消息</li>
<li>参数3<code>count</code>：存放空间的大小</li>
<li>返回值：成功则返回实际读出的消息大小，失败返回-1</li>
</ul>
<h4 id="4-2-4-关闭管道"><a href="#4-2-4-关闭管道" class="headerlink" title="4.2.4 关闭管道"></a>4.2.4 关闭管道</h4><p>可以单独关闭写端和读端</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">close(pipefd[<span class="number">0</span>]);</span><br><span class="line">close(pipefd[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<h4 id="4-2-5-实例"><a href="#4-2-5-实例" class="headerlink" title="4.2.5 实例"></a>4.2.5 实例</h4><p>前面说到，需要通过pipe产生的句柄来进行读写，那是不是只要知道这个句柄，就可以实现进程之间的通信了呢？可以看下面的一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @file: pipe.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERR_EXIT(m) \</span></span><br><span class="line"><span class="meta">    do &#123;            \</span></span><br><span class="line"><span class="meta">        perror(0);  \</span></span><br><span class="line"><span class="meta">        exit(EXIT_FAILURE);   \</span></span><br><span class="line"><span class="meta">    &#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 100</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @file: pipe_write.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pipe.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> buf[BUFSIZE] = <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ERR_EXIT(<span class="string">&quot;pipe()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    write(pipefd[<span class="number">1</span>], buf, BUFSIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read fd = %d\n&quot;</span>, pipefd[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;write: %s\n&quot;</span>, buf);</span><br><span class="line">    sleep(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @file: pipe_read.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pipe.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> rfd = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="keyword">if</span> (read(rfd, buf, BUFSIZE) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ERR_EXIT(<span class="string">&quot;read()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read: %s\n&quot;</span>, buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%85%E6%9E%90System%20V%E5%92%8CPOSIX%E4%B8%8B%E7%9A%84IPC/选区_007.png" alt="选区_007"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pipe.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> write_buf[BUFSIZE];</span><br><span class="line">    <span class="type">char</span> read_buf[BUFSIZE];</span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ERR_EXIT(<span class="string">&quot;pipe()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read fd = %d\n&quot;</span>, pipefd[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;write fd = %d\n&quot;</span>, pipefd[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ERR_EXIT(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// parent proc</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is writer\nwrite fd = %d\n&quot;</span>, pipefd[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(write_buf, <span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">            write(pipefd[<span class="number">1</span>], write_buf, BUFSIZE);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;write: %s\n&quot;</span>, write_buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// child proc</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t\t\t\tthis is reader\n\t\t\t\tread fd = %d\n&quot;</span>, pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">            read(pipefd[<span class="number">0</span>], read_buf, BUFSIZE);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\t\t\t\tread: %s\n&quot;</span>, read_buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    close(pipefd[<span class="number">0</span>]);</span><br><span class="line">    close(pipefd[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%85%E6%9E%90System%20V%E5%92%8CPOSIX%E4%B8%8B%E7%9A%84IPC/选区_008.png" alt="选区_008"></p>
<h3 id="4-3-命名管道"><a href="#4-3-命名管道" class="headerlink" title="4.3 命名管道"></a>4.3 命名管道</h3><p>​        命名管道拥有更广的使用范围，因为任何进程只要知道该命名管道的名字，就可以通过open()进行打开访问。而且命名管道是半双工通信，即当有进程打开了管道时，另外试图打开的进程默认会发生阻塞。</p>
<h4 id="4-3-1-创建管道-mkfifo"><a href="#4-3-1-创建管道-mkfifo" class="headerlink" title="4.3.1 创建管道 mkfifo"></a>4.3.1 创建管道 mkfifo</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>功能：创建一个指定名称的管道</li>
<li>参数1<code>pathname</code>：一个文件路径，每个命名管道会与一个文件绑定，也就是说它可以看作是文件系统的一部分，但是当在进行消息传输时，这些消息并不会被写入文件中，而是直接写到由内核管理的内存中，这个文件只是起到一个key的作用，以便其它进程也能够获取到该管道。（这一点类似于POSIX</li>
<li>参数2<code>mode</code>：管道的访问权限</li>
<li>返回值：成功返回0，失败返回-1</li>
</ul>
<h4 id="4-3-2-打开管道-open"><a href="#4-3-2-打开管道-open" class="headerlink" title="4.3.2 打开管道 open"></a>4.3.2 打开管道 open</h4><p>创建管道之后，还需要打开才能进行操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>参数1<code>pathname</code>：管道名</li>
<li>参数2<code>flags</code>：操作标志位<ul>
<li>O_RDWR</li>
<li>O_RDONLY</li>
</ul>
</li>
<li>返回值：成功返回管道的文件句柄，失败返回-1</li>
</ul>
<h4 id="4-3-3-写入-读出消息"><a href="#4-3-3-写入-读出消息" class="headerlink" title="4.3.3 写入/读出消息"></a>4.3.3 写入/读出消息</h4><p>同样是使用write和read系统调用</p>
<h4 id="4-3-4-关闭管道"><a href="#4-3-4-关闭管道" class="headerlink" title="4.3.4 关闭管道"></a>4.3.4 关闭管道</h4><p>同样是使用close</p>
<h4 id="4-3-5-删除管道"><a href="#4-3-5-删除管道" class="headerlink" title="4.3.5 删除管道"></a>4.3.5 删除管道</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span></span><br></pre></td></tr></table></figure>
<p>不像匿名管道，只要与之有关的进程结束就会自动删除，命名管道需要手动进行删除。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">HogarHuang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://huanghj78.github.io/2022/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%85%E6%9E%90System%20V%E5%92%8CPOSIX%E4%B8%8B%E7%9A%84IPC/">https://huanghj78.github.io/2022/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%85%E6%9E%90System%20V%E5%92%8CPOSIX%E4%B8%8B%E7%9A%84IPC/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post_share"><div class="social-share" data-image="/images/background.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://fastly.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OS-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/"><img class="next-cover" src="/images/background.jpg" onerror="onerror=null;src='/img/night.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">OS-线程调度</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%85%E6%9E%90System-V%E5%92%8CPOSIX%E4%B8%8B%E7%9A%84IPC"><span class="toc-number">1.</span> <span class="toc-text">浅析System V和POSIX下的IPC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%BC%95%E8%A8%80%E4%B8%8E%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">1. 引言与概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98-Shared-Memory"><span class="toc-number">1.2.</span> <span class="toc-text">2. 共享内存 Shared Memory</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-System-V"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 System V</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E7%94%9F%E6%88%90%E9%94%AE%E5%80%BC-ftok"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">2.2.1 生成键值 ftok</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E5%88%9B%E5%BB%BA%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98-shmget"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.2.2 创建共享内存 shmget</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E6%98%A0%E5%B0%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98-shmat"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">2.2.3 映射共享内存 shmat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-%E8%A7%A3%E9%99%A4%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84-shmdt"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">2.2.4 解除内存映射 shmdt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-5-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6-shmctl"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">2.2.5 共享内存控制 shmctl</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-POSIX"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 POSIX</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E5%88%9B%E5%BB%BA-%E6%89%93%E5%BC%80%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98-shm-open"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">2.3.1 创建&#x2F;打开共享内存 shm_open</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E8%AE%BE%E7%BD%AE%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F-ftruncate"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2.3.2 设置共享内存大小 ftruncate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84-mmap"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">2.3.3 内存映射 mmap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-4-%E5%88%A0%E9%99%A4%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98-shm-unlink"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">2.3.4 删除共享内存 shm_unlink</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-5-%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">2.3.5 实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%AF%94%E8%BE%83"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92-Message-Passing"><span class="toc-number">1.3.</span> <span class="toc-text">3. 消息传递 Message Passing</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-System-V"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 System V</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E5%88%9B%E5%BB%BA-%E8%8E%B7%E5%8F%96%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-msgget"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">3.2.1 创建&#x2F;获取消息队列 msgget</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF-msgsnd"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">3.2.2 发送消息  msgsnd</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF-msgrcv"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">3.2.3 接收消息 msgrcv</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%8E%A7%E5%88%B6-msgctl"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">3.2.4 消息队列控制 msgctl</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-5-%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">3.2.5 实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-POSIX"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 POSIX</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E5%88%9B%E5%BB%BA-%E8%8E%B7%E5%8F%96%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-mq-open"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">3.3.1 创建&#x2F;获取消息队列 mq_open</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-%E5%85%B3%E9%97%AD%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-mq-closse"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">3.3.2 关闭消息队列 mq_closse</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF-mq-send"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">3.3.3 发送消息 mq_send</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-4-%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF-mq-receive"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">3.3.4 接收消息 mq_receive</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-5-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%B1%9E%E6%80%A7%E7%9B%B8%E5%85%B3-mq-setattr-mq-getattr"><span class="toc-number">1.3.3.5.</span> <span class="toc-text">3.3.5 消息队列属性相关 mq_setattr mq_getattr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-6-%E5%BC%82%E6%AD%A5%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5-mq-notify"><span class="toc-number">1.3.3.6.</span> <span class="toc-text">3.3.6 异步事件通知 mq_notify</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-7-%E5%88%A0%E9%99%A4%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-mq-unlink"><span class="toc-number">1.3.3.7.</span> <span class="toc-text">3.3.7 删除消息队列 mq_unlink</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%AF%94%E8%BE%83"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4 比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%AE%A1%E9%81%93"><span class="toc-number">1.4.</span> <span class="toc-text">4. 管道</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2 匿名管道</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include"><span class="toc-number">2.</span> <span class="toc-text">include </span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E5%88%9B%E5%BB%BA%E7%AE%A1%E9%81%93pipe"><span class="toc-number">2.0.0.1.</span> <span class="toc-text">4.2.1 创建管道pipe</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E5%86%99%E5%85%A5%E6%B6%88%E6%81%AF-write"><span class="toc-number">2.0.0.2.</span> <span class="toc-text">4.2.2 写入消息 write</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-%E8%AF%BB%E5%87%BA%E6%B6%88%E6%81%AF-read"><span class="toc-number">2.0.0.3.</span> <span class="toc-text">4.2.3 读出消息 read</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-%E5%85%B3%E9%97%AD%E7%AE%A1%E9%81%93"><span class="toc-number">2.0.0.4.</span> <span class="toc-text">4.2.4 关闭管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-5-%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.0.0.5.</span> <span class="toc-text">4.2.5 实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-number">2.0.1.</span> <span class="toc-text">4.3 命名管道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-%E5%88%9B%E5%BB%BA%E7%AE%A1%E9%81%93-mkfifo"><span class="toc-number">2.0.1.1.</span> <span class="toc-text">4.3.1 创建管道 mkfifo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-%E6%89%93%E5%BC%80%E7%AE%A1%E9%81%93-open"><span class="toc-number">2.0.1.2.</span> <span class="toc-text">4.3.2 打开管道 open</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-3-%E5%86%99%E5%85%A5-%E8%AF%BB%E5%87%BA%E6%B6%88%E6%81%AF"><span class="toc-number">2.0.1.3.</span> <span class="toc-text">4.3.3 写入&#x2F;读出消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-4-%E5%85%B3%E9%97%AD%E7%AE%A1%E9%81%93"><span class="toc-number">2.0.1.4.</span> <span class="toc-text">4.3.4 关闭管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-5-%E5%88%A0%E9%99%A4%E7%AE%A1%E9%81%93"><span class="toc-number">2.0.1.5.</span> <span class="toc-text">4.3.5 删除管道</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/luka.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">HogarHuang</div><div class="author-info__description">1353188493@qq.com</div></div></div></div></div></main><footer id="footer" style="background: #FFFFFF"><div id="footer-wrap"><div class="copyright">&copy;2022 By HogarHuang</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/chenxz21/hexo-theme-bcxm">Bcxm</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://fastly.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/leancloud-storage@4.10.0/dist/av-min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>